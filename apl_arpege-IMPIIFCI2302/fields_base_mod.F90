MODULE FIELDS_BASE_MOD
USE PARKIND1,                        ONLY : JPRB, JPIM
USE YOMLUN,                          ONLY : NULOUT
USE YOMCT0,                          ONLY : LELAM
USE GEOMETRY_MOD,                    ONLY : GEOMETRY,GEOMETRY_SAME
USE TYPE_MODEL,                      ONLY : MODEL
USE FIELD_CONTAINER_GP_MOD,          ONLY : FIELD_CONTAINER_GP
USE VARIABLES_MOD,                   ONLY : VARIABLES, VARIABLES_CLONE, VARIABLES_DELETE
USE ORDER_INDEPENDENT_SUMMATION_MOD, ONLY : ORDER_INDEP_GLOBAL_SUM
USE YOMMP0,                          ONLY : NPROC
USE FIELD_DEFINITIONS,               ONLY : FIELD_ACCESS,FID
USE IOSTREAM_MIX,                    ONLY : SETUP_IOSTREAM, SETUP_IOREQUEST, &
 &                                          IO_PUT, CLOSE_IOSTREAM, TYPE_IOSTREAM, TYPE_IOREQUEST, CLOSE_IOREQUEST,YGBH, IO_GET
USE YOMGRIB,                         ONLY : NLOCGRB
USE GRIB_HANDLES_MOD,                ONLY : TYPE_GRIB_HANDLES,RELEASE_GRIB_HANDLES

USE YOMHOOK,                         ONLY : LHOOK, DR_HOOK, JPHOOK

IMPLICIT NONE
#include "abor1.intfb.h"
PRIVATE
TYPE, PUBLIC :: FIELDS_BASE
  TYPE(VARIABLES)                   :: VARS
  TYPE(FIELD_CONTAINER_GP)          :: FIELDSTORE
  TYPE(GEOMETRY),           POINTER :: GEOM        => NULL()
  TYPE(MODEL),              POINTER :: STATE_MODEL => NULL()
  TYPE(FIELD_CONTAINER_GP), POINTER :: FIELD       => NULL()
  CONTAINS
  PROCEDURE :: FIELDS_CREATE
  PROCEDURE :: FIELDS_DELETE
  PROCEDURE :: FIELDS_ZEROS
  PROCEDURE :: FIELDS_COPY
  PROCEDURE :: FIELDS_SET_MODEL
  PROCEDURE :: FIELDS_AXPY
  PROCEDURE :: FIELDS_ADD
  PROCEDURE :: FIELDS_SUB
  PROCEDURE :: FIELDS_MUL
  PROCEDURE :: FIELDS_DOT_PROD
  PROCEDURE :: FIELDS_SCHUR_PROD
  PROCEDURE :: FIELDS_ADD_INCR
  PROCEDURE :: FIELDS_DIFF_INCR
  PROCEDURE :: FIELDS_NORM
  PROCEDURE :: FIELDS_L2_NORM
  PROCEDURE :: FIELDS_GPNORM
  PROCEDURE :: FIELDS_WRITE
  PROCEDURE :: FIELDS_READ
  PROCEDURE :: FIELDS_RANDOM
  PROCEDURE :: FIELDS_PGPSP
  FINAL :: FIELDS_BASE_FINAL
END TYPE FIELDS_BASE

PUBLIC INTREST,SPLIT_SPEC_GP
CONTAINS
!==========================================================================================

SUBROUTINE FIELDS_CREATE(SELF, GEOM, VARS)
USE FIELD_DEFINITIONS, ONLY : FID,MAIN_FIELD_METADATA
CLASS(FIELDS_BASE), TARGET, INTENT(INOUT) :: SELF
TYPE(GEOMETRY),     TARGET, INTENT(IN)    :: GEOM
TYPE(VARIABLES),            INTENT(IN)    :: VARS
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_CREATE',0,ZHOOK_HANDLE)
IF(.NOT.ASSOCIATED(VARS%FIELDIDS)) CALL ABOR1('FIELDS_BASE_MOD:FIELDS_CREATE - VARS%FIELDIDS NOT ALLOCATED')
WRITE(NULOUT,*) 'FIELDS_BASE_MOD:ENTER FIELDS_CREATE ',VARS%FIELDIDS
SELF%GEOM => GEOM
CALL VARIABLES_CLONE(SELF%VARS, VARS)
SELF%FIELD => SELF%FIELDSTORE
CALL SELF%FIELD%FIELD_CREATE(MAIN_FIELD_METADATA,SELF%GEOM%YRGEM%NGPTOT, &
 & (/ SELF%GEOM%YRDIMV%NFLEVG, SELF%GEOM%YRDIMV%NFLEVG+1,4,1,1,1,1,1,1,1,1/),&
 & SELF%GEOM%YRDIM%NPROMA,KFIDS=SELF%VARS%FIELDIDS)

CALL SELF%FIELDS_ZEROS
!! the base fields_create (increment) does not have a model, so we can not
!! set the model pointer at this point

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_CREATE',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_CREATE
!==========================================================================================

SUBROUTINE FIELDS_DELETE(SELF)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_DELETE',0,ZHOOK_HANDLE)
CALL SELF%FIELD%FIELD_DESTROY()
SELF%FIELD => NULL()
SELF%GEOM => NULL()
SELF%STATE_MODEL => NULL()
CALL VARIABLES_DELETE(SELF%VARS)
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_DELETE',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_DELETE
!==========================================================================================

SUBROUTINE FIELDS_ZEROS(SELF)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
INTEGER(KIND=JPIM) :: JBLK
TYPE(FIELD_ACCESS)  :: YLFAC
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_ZEROS',0,ZHOOK_HANDLE)
DO JBLK=1,SELF%GEOM%YRDIM%NGPBLKS
  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=SELF%VARS%FIELDIDS,KBLOCK=JBLK,FAC=YLFAC) == 1)
    IF(ASSOCIATED(YLFAC%RR1)) THEN
      YLFAC%RR1(:) = 0.0_JPRB
    ELSE
      YLFAC%RR2(:,:) = 0.0_JPRB
    ENDIF
  ENDDO
ENDDO
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_ZEROS',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_ZEROS
!==========================================================================================

SUBROUTINE FIELDS_MUL(SELF,PZ)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
REAL(KIND=JPRB),          INTENT(IN)    :: PZ
INTEGER(KIND=JPIM) :: JBLK,IST,IEND,IKGLO
TYPE(FIELD_ACCESS)  :: YLFAC
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_MUL',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>SELF%GEOM%YRDIM,YDDIMV=>SELF%GEOM%YRDIMV,YDGEM=>SELF%GEOM%YRGEM)
ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, &
 & NGPTOT=>YDGEM%NGPTOT)
DO JBLK=1,SELF%GEOM%YRDIM%NGPBLKS
  IKGLO = 1+(JBLK-1)*NPROMA
  IST = 1
  IEND = MIN(NPROMA,NGPTOT-IKGLO+1)
  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=SELF%VARS%FIELDIDS,KBLOCK=JBLK,FAC=YLFAC) == 1)
    IF(ASSOCIATED(YLFAC%RR1)) THEN
      YLFAC%RR1(IST:IEND) = PZ*YLFAC%RR1(IST:IEND)
    ELSE
      YLFAC%RR2(IST:IEND,:) = PZ*YLFAC%RR2(IST:IEND,:)
    ENDIF
  ENDDO
ENDDO
END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_MUL',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_MUL
!==========================================================================================

SUBROUTINE FIELDS_COPY(SELF,RHS,KFIDS)
USE FIELD_CONTAINER_OPER_MOD, ONLY : FIELD_CONTAINER_INTERP
USE FIELD_DEFINITIONS, ONLY : FID,MAIN_FIELD_METADATA
USE YOMCT0, ONLY : NINTERPINCR
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CLASS(FIELDS_BASE),TARGET,INTENT(INOUT) :: RHS
INTEGER(KIND=JPIM),OPTIONAL,TARGET,INTENT(IN) :: KFIDS(:)
TYPE(FIELD_ACCESS),POINTER  :: YLFAC,YLRHS
INTEGER(KIND=JPIM) :: JBLK
INTEGER(KIND=JPIM),POINTER :: IFIDS(:)
INTEGER(KIND=JPIM),ALLOCATABLE :: IFIDS_GP(:),IFIDS_SPEC(:)
REAL(KIND=JPRB),ALLOCATABLE    :: ZGPSPGLO(:,:)
TYPE(FIELDS_BASE),TARGET       :: RHS_SELFRES
TYPE(FIELDS_BASE),POINTER      :: RHS_SELFRES_PTR
LOGICAL :: LLSAME_RESOL,LLSPEC_INT
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_COPY',0,ZHOOK_HANDLE)
LLSPEC_INT=.FALSE.
IF(PRESENT(KFIDS)) THEN
  IFIDS => KFIDS
ELSE
  IF(.NOT.ASSOCIATED(SELF%VARS%FIELDIDS)) CALL ABOR1('FIELDS_BASE_MOD:FIELDS_COPY - FIELDIDS MISSING')
  IFIDS => SELF%VARS%FIELDIDS
ENDIF
LLSAME_RESOL = GEOMETRY_SAME(SELF%GEOM,RHS%GEOM)
IF(LLSAME_RESOL) THEN
  RHS_SELFRES_PTR => RHS
ELSE
  WRITE(NULOUT,*) 'FIELDS_BASE_MOD: FIELDS_COPY INTERP',SELF%GEOM%YRGEM%NGPTOTG,RHS%GEOM%YRGEM%NGPTOTG,LLSPEC_INT
  IF(LLSPEC_INT) THEN
    CALL SPLIT_SPEC_GP(IFIDS,IFIDS_SPEC,IFIDS_GP)
    WRITE(NULOUT,*) 'FIELDS_BASE_MOD:FIELDS_COPY - IFIDS_GP',IFIDS_GP
    WRITE(NULOUT,*) 'FIELDS_BASE_MOD:FIELDS_COPY - IFIDS_SPEC',IFIDS_SPEC
  ELSE
    ALLOCATE(IFIDS_GP(SIZE(IFIDS)))
    IFIDS_GP = IFIDS
  ENDIF
  RHS_SELFRES%GEOM => SELF%GEOM
  CALL VARIABLES_CLONE(RHS_SELFRES%VARS, RHS%VARS)
  RHS_SELFRES%FIELD => RHS_SELFRES%FIELDSTORE
  CALL RHS_SELFRES%FIELD%FIELD_CREATE(MAIN_FIELD_METADATA,RHS_SELFRES%GEOM%YRGEM%NGPTOT, &
   & (/ RHS_SELFRES%GEOM%YRDIMV%NFLEVG, RHS_SELFRES%GEOM%YRDIMV%NFLEVG+1,4,1,1,1,1,1,1,1,1/),&
   & RHS_SELFRES%GEOM%YRDIM%NPROMA,KFIDS=IFIDS)
  IF(NINTERPINCR == 1) THEN
    ! Bi-linear interpolation
    IF(LLSPEC_INT) THEN
      CALL FIELD_CONTAINER_INTERP(RHS%GEOM,RHS_SELFRES%GEOM,RHS%FIELD,RHS_SELFRES%FIELD,KFIDS_SPEC=IFIDS_SPEC)
    ELSE
      CALL FIELD_CONTAINER_INTERP(RHS%GEOM,RHS_SELFRES%GEOM,RHS%FIELD,RHS_SELFRES%FIELD)
    ENDIF
  ELSEIF(NINTERPINCR == 3) THEN
    ! Conserving interpolation
    IF(SELF%GEOM%YRDIM%NSMAX < RHS%GEOM%YRDIM%NSMAX) THEN
      ALLOCATE(ZGPSPGLO(RHS%GEOM%YRGEM%NGPTOTG,1))
      CALL RHS%FIELDS_PGPSP(ZGPSPGLO)
    ELSE
      ALLOCATE(ZGPSPGLO(SELF%GEOM%YRGEM%NGPTOTG,1))
      CALL SELF%FIELDS_PGPSP(ZGPSPGLO)
    ENDIF
    IF(LLSPEC_INT) THEN
      CALL FIELD_CONTAINER_INTERP(RHS%GEOM,RHS_SELFRES%GEOM,RHS%FIELD,RHS_SELFRES%FIELD,KFIDS_SPEC=IFIDS_SPEC,PGPSPGLO=ZGPSPGLO)
    ELSE
      CALL FIELD_CONTAINER_INTERP(RHS%GEOM,RHS_SELFRES%GEOM,RHS%FIELD,RHS_SELFRES%FIELD,PGPSPGLO=ZGPSPGLO)
    ENDIF
  ELSE
    CALL ABOR1('FIELDS_BASE_MOD: FIELDS_COPY - INVALID CHOICE OF INTERPOLATION TYPE')
  ENDIF
  RHS_SELFRES_PTR => RHS_SELFRES
ENDIF
WRITE(NULOUT,*) 'FIELDS_BASE_MOD:ENTER FIELDS_COPY',IFIDS

!$OMP PARALLEL PRIVATE(JBLK,YLFAC,YLRHS)
ALLOCATE(YLFAC,YLRHS)
!$OMP DO SCHEDULE(STATIC)
DO JBLK=1,SELF%GEOM%YRDIM%NGPBLKS
  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=IFIDS,KBLOCK=JBLK,FAC=YLFAC) + &
   & RHS_SELFRES_PTR%FIELD%FIELD_ITERATED(KFIDS=IFIDS,KBLOCK=JBLK,FAC=YLRHS)  == 2)
    IF(ASSOCIATED(YLFAC%RR1)) THEN
      YLFAC%RR1(:) = YLRHS%RR1(:)
    ELSE
      YLFAC%RR2(:,:) = YLRHS%RR2(:,:)
    ENDIF
  ENDDO
ENDDO
!$OMP END DO
DEALLOCATE(YLFAC,YLRHS)
!$OMP END PARALLEL

RHS_SELFRES_PTR => NULL()
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_COPY',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_COPY
!==========================================================================================

SUBROUTINE FIELDS_SET_MODEL(SELF,YDMODEL)
CLASS(FIELDS_BASE),         INTENT(INOUT) :: SELF
TYPE(MODEL)       , TARGET, INTENT(IN)    :: YDMODEL

!! point the model pointer in self to the model passed in
SELF%STATE_MODEL => YDMODEL

END SUBROUTINE FIELDS_SET_MODEL
!==========================================================================================

SUBROUTINE FIELDS_AXPY(SELF,PZ,RHS,KFIDS,KFIDS_POSITIVE,LDSPEC_INT)
USE FIELD_CONTAINER_OPER_MOD, ONLY : FIELD_CONTAINER_INTERP,FIELD_CONTAINER_AXPY_SPEC
USE FIELD_DEFINITIONS, ONLY : FID,MAIN_FIELD_METADATA
USE YOMCT0, ONLY : NINTERPINCR
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CLASS(FIELDS_BASE),TARGET,INTENT(INOUT) :: RHS
REAL(KIND=JPRB),          INTENT(IN)    :: PZ
INTEGER(KIND=JPIM),OPTIONAL,TARGET,INTENT(IN) :: KFIDS(:)
INTEGER(KIND=JPIM),OPTIONAL,TARGET,INTENT(IN) :: KFIDS_POSITIVE(:)
LOGICAL,OPTIONAL,INTENT(IN) :: LDSPEC_INT

INTEGER(KIND=JPIM) :: JBLK,IST,IEND,IKGLO
TYPE(FIELD_ACCESS), POINTER  :: YLFAC,YLRHS
INTEGER(KIND=JPIM),POINTER :: IFIDS(:)
INTEGER(KIND=JPIM),ALLOCATABLE :: IFIDS_GP(:),IFIDS_SPEC(:)
REAL(KIND=JPRB),ALLOCATABLE :: ZGPSPGLO(:,:)
TYPE(FIELDS_BASE),TARGET    :: RHS_SELFRES
TYPE(FIELDS_BASE),POINTER   :: RHS_SELFRES_PTR
LOGICAL :: LLSAME_RESOL,LLSPEC_INT
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_AXPY',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>SELF%GEOM%YRDIM,YDDIMV=>SELF%GEOM%YRDIMV,YDGEM=>SELF%GEOM%YRGEM)
ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, &
 & NGPTOT=>YDGEM%NGPTOT)
LLSPEC_INT = .FALSE.
IF(PRESENT(LDSPEC_INT)) LLSPEC_INT = LDSPEC_INT
IF(PRESENT(KFIDS)) THEN
  IFIDS => KFIDS
ELSE
  IFIDS => SELF%VARS%FIELDIDS
ENDIF
LLSAME_RESOL = GEOMETRY_SAME(SELF%GEOM,RHS%GEOM)
IF(LLSAME_RESOL) THEN
  RHS_SELFRES_PTR => RHS
  ALLOCATE(IFIDS_GP(SIZE(IFIDS)))
  IFIDS_GP(:) = IFIDS(:)
ELSE
  WRITE(NULOUT,*) 'FIELDS_BASE_MOD: FIELDS_AXPY INTERP',SELF%GEOM%YRGEM%NGPTOTG,RHS%GEOM%YRGEM%NGPTOTG,LLSPEC_INT
  IF(LLSPEC_INT) THEN
    CALL SPLIT_SPEC_GP(IFIDS,IFIDS_SPEC,IFIDS_GP)
    WRITE(NULOUT,*) 'FIELDS_BASE_MOD:FIELDS_AXPY - IFIDS_GP',IFIDS_GP
    WRITE(NULOUT,*) 'FIELDS_BASE_MOD:FIELDS_AXPY - IFIDS_SPEC',IFIDS_SPEC
    CALL FIELD_CONTAINER_AXPY_SPEC(SELF%GEOM,RHS%GEOM,SELF%FIELD,PZ,RHS%FIELD,IFIDS_SPEC)
  ELSE
    ALLOCATE(IFIDS_GP(SIZE(IFIDS)))
    IFIDS_GP = IFIDS
  ENDIF
  RHS_SELFRES%GEOM => SELF%GEOM
  CALL VARIABLES_CLONE(RHS_SELFRES%VARS, RHS%VARS)
  RHS_SELFRES%FIELD => RHS_SELFRES%FIELDSTORE
  CALL RHS_SELFRES%FIELD%FIELD_CREATE(MAIN_FIELD_METADATA,RHS_SELFRES%GEOM%YRGEM%NGPTOT, &
   & (/ RHS_SELFRES%GEOM%YRDIMV%NFLEVG, RHS_SELFRES%GEOM%YRDIMV%NFLEVG+1,4,1,1,1,1,1,1,1,1/),&
   & RHS_SELFRES%GEOM%YRDIM%NPROMA,KFIDS=IFIDS_GP)
  IF(NINTERPINCR == 1) THEN
    ! Bi-linear interpolation
    CALL FIELD_CONTAINER_INTERP(RHS%GEOM,RHS_SELFRES%GEOM,RHS%FIELD,RHS_SELFRES%FIELD)
  ELSEIF(NINTERPINCR == 3) THEN
    ! Conserving interpolation
    IF(SELF%GEOM%YRDIM%NSMAX < RHS%GEOM%YRDIM%NSMAX) THEN
      ALLOCATE(ZGPSPGLO(RHS%GEOM%YRGEM%NGPTOTG,1))
      CALL RHS%FIELDS_PGPSP(ZGPSPGLO)
    ELSE
      ALLOCATE(ZGPSPGLO(SELF%GEOM%YRGEM%NGPTOTG,1))
      CALL SELF%FIELDS_PGPSP(ZGPSPGLO)
    ENDIF
    CALL FIELD_CONTAINER_INTERP(RHS%GEOM,RHS_SELFRES%GEOM,RHS%FIELD,RHS_SELFRES%FIELD,PGPSPGLO=ZGPSPGLO)
  ELSE
    CALL ABOR1('FIELDS_BASE_MOD: FIELDS_AXPY - INVALID CHOICE OF INTERPOLATION TYPE')
  ENDIF
  WRITE(NULOUT,*) 'FIELDS_BASE_MOD:FIELDS_AXPY - INTERPOLATION DONE'
  RHS_SELFRES_PTR => RHS_SELFRES
ENDIF

!$OMP PARALLEL PRIVATE(JBLK,IKGLO,IST,IEND,YLFAC,YLRHS)
ALLOCATE(YLFAC,YLRHS)
!$OMP DO SCHEDULE(STATIC)
DO JBLK=1,SELF%GEOM%YRDIM%NGPBLKS
  IKGLO = 1+(JBLK-1)*NPROMA
  IST = 1
  IEND = MIN(NPROMA,NGPTOT-IKGLO+1)
  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=IFIDS_GP,KBLOCK=JBLK,FAC=YLFAC) + &
   & RHS_SELFRES_PTR%FIELD%FIELD_ITERATED(KFIDS=IFIDS_GP,KBLOCK=JBLK,FAC=YLRHS)  == 2)
    IF(ASSOCIATED(YLFAC%RR1)) THEN
      YLFAC%RR1(IST:IEND) = YLFAC%RR1(IST:IEND)+ PZ*YLRHS%RR1(IST:IEND)
    ELSE
      YLFAC%RR2(IST:IEND,:) = YLFAC%RR2(IST:IEND,:)+PZ*YLRHS%RR2(IST:IEND,:)
    ENDIF
  ENDDO
ENDDO
!$OMP END DO

! Ensure selected fields are positive
IF(PRESENT(KFIDS_POSITIVE)) THEN
  !$OMP DO SCHEDULE(STATIC)
  DO JBLK=1,SELF%GEOM%YRDIM%NGPBLKS
    IKGLO = 1+(JBLK-1)*NPROMA
    IST = 1
    IEND = MIN(NPROMA,NGPTOT-IKGLO+1)
    DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=KFIDS_POSITIVE,KBLOCK=JBLK,FAC=YLFAC) + &
     & RHS_SELFRES_PTR%FIELD%FIELD_ITERATED(KFIDS=KFIDS_POSITIVE,KBLOCK=JBLK,FAC=YLRHS)  == 2)
      IF(ASSOCIATED(YLFAC%RR1)) THEN
        YLFAC%RR1(IST:IEND) = MAX(YLFAC%RR1(IST:IEND),0.0_JPRB)
      ELSE
        YLFAC%RR2(IST:IEND,:) = MAX(YLFAC%RR2(IST:IEND,:),0.0_JPRB)
      ENDIF
    ENDDO
  ENDDO
  !$OMP END DO
ENDIF

DEALLOCATE(YLFAC,YLRHS)
!$OMP END PARALLEL

RHS_SELFRES_PTR => NULL()

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_AXPY',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_AXPY
!==========================================================================================

SUBROUTINE FIELDS_ADD(SELF,RHS)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CLASS(FIELDS_BASE),       INTENT(INOUT) :: RHS
integer(kind=jpim),save :: invocation=0
character(len=32) :: clfname
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_ADD',0,ZHOOK_HANDLE)
CALL FIELDS_AXPY(SELF,1.0_JPRB,RHS,LDSPEC_INT=.FALSE.)
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_ADD',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_ADD
!==========================================================================================

SUBROUTINE FIELDS_SUB(SELF,RHS,KFIDS)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CLASS(FIELDS_BASE),       INTENT(INOUT) :: RHS
INTEGER(KIND=JPIM),OPTIONAL,TARGET,INTENT(IN) :: KFIDS(:)
INTEGER(KIND=JPIM),POINTER :: IFIDS(:)
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_SUB',0,ZHOOK_HANDLE)
IF(PRESENT(KFIDS)) THEN
  IFIDS => KFIDS
ELSE
  IF(.NOT.ASSOCIATED(SELF%VARS%FIELDIDS)) CALL ABOR1('FIELDS_BASE_MOD:FIELDS_SUB - FIELDIDS MISSING')
  IFIDS => SELF%VARS%FIELDIDS
ENDIF
WRITE(NULOUT,*) 'FIELDS_BASE_MOD:ENTER FIELDS_SUB',IFIDS
CALL FIELDS_AXPY(SELF,-1.0_JPRB,RHS,KFIDS=IFIDS,LDSPEC_INT=.FALSE.)
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_SUB',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_SUB
!==========================================================================================

SUBROUTINE FIELDS_DOT_PROD(SELF,RHS,PDOTP)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CLASS(FIELDS_BASE),       INTENT(INOUT) :: RHS
REAL(KIND=JPRB),          INTENT(OUT)   :: PDOTP
TYPE(FIELD_ACCESS)  :: YLFAC,YLRHS
REAL(KIND=JPRB) :: ZZ(1)
INTEGER(KIND=JPIM) :: JCOL,JBLK,ITID,IST,IEND,IBL,JL,IKGLO
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_DOT_PROD',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>SELF%GEOM%YRDIM,YDDIMV=>SELF%GEOM%YRDIMV,YDGEM=>SELF%GEOM%YRGEM)
ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, &
 & NGPTOT=>YDGEM%NGPTOT)
IF(.NOT.GEOMETRY_SAME(SELF%GEOM,RHS%GEOM)) CALL ABOR1('FIELDS_BASE_MOD:FIELDS_DOT_PROD DIFFERENT RESOLUTION')
PDOTP = 0.0
ZZ = 0.0

DO JBLK=1,SELF%GEOM%YRDIM%NGPBLKS
  IKGLO = 1+(JBLK-1)*NPROMA
  IST = 1
  IEND = MIN(NPROMA,NGPTOT-IKGLO+1)
  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=SELF%VARS%FIELDIDS,KBLOCK=JBLK,FAC=YLFAC,KOTID=ITID) + &
   & RHS%FIELD%FIELD_ITERATED(KFIDS=SELF%VARS%FIELDIDS,KBLOCK=JBLK,FAC=YLRHS)  == 2)
    IF(ASSOCIATED(YLFAC%RR1)) THEN
      IF(.NOT.ASSOCIATED(YLRHS%RR1)) CALL ABOR1('FIELDS_BASE_MOD:FIELDS_DOT_PROD - ZRHS_1D NOT ASSOCIATED')
      ZZ(1) = ZZ(1)+DOT_PRODUCT(YLFAC%RR1(IST:IEND),YLRHS%RR1(IST:IEND))
    ELSE
      IF(.NOT.ASSOCIATED(YLRHS%RR2)) CALL ABOR1('FIELDS_BASE_MOD:FIELDS_DOT_PROD - ZRHS_2D NOT ASSOCIATED')
      DO JCOL=1,SIZE(YLFAC%RR2(1,:))
        ZZ(1) = ZZ(1)+DOT_PRODUCT(YLFAC%RR2(IST:IEND,JCOL),YLRHS%RR2(IST:IEND,JCOL))
      ENDDO
    ENDIF
  ENDDO
ENDDO
PDOTP = ORDER_INDEP_GLOBAL_SUM(ZZ,KNG=1)

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_DOT_PROD',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_DOT_PROD
!========================================================================================

SUBROUTINE FIELDS_L2_NORM(SELF,PDOTP)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
REAL(KIND=JPRB),          INTENT(OUT)   :: PDOTP
TYPE(FIELD_ACCESS)  :: YLFAC
REAL(KIND=JPRB) :: ZZ(1)
INTEGER(KIND=JPIM) :: JCOL,JBLK,ITID,IST,IEND,IBL,JL,IKGLO
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_L2_NORM',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>SELF%GEOM%YRDIM,YDDIMV=>SELF%GEOM%YRDIMV,YDGEM=>SELF%GEOM%YRGEM)
ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, &
 & NGPTOT=>YDGEM%NGPTOT)

PDOTP = 0.0
ZZ = 0.0

DO JBLK=1,SELF%GEOM%YRDIM%NGPBLKS
  IKGLO = 1+(JBLK-1)*NPROMA
  IST = 1
  IEND = MIN(NPROMA,NGPTOT-IKGLO+1)
  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=SELF%VARS%FIELDIDS,KBLOCK=JBLK,FAC=YLFAC,KOTID=ITID) == 1)
    IF(ASSOCIATED(YLFAC%RR1)) THEN
      ZZ(1) = ZZ(1)+DOT_PRODUCT(YLFAC%RR1(IST:IEND),YLFAC%RR1(IST:IEND))
    ELSE
       DO JCOL=1,SIZE(YLFAC%RR2(1,:))
         ZZ(1) = ZZ(1)+DOT_PRODUCT(YLFAC%RR2(IST:IEND,JCOL),YLFAC%RR2(IST:IEND,JCOL))
      ENDDO
    ENDIF
  ENDDO
ENDDO
PDOTP = ORDER_INDEP_GLOBAL_SUM(ZZ,KNG=1)

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_L2_NORM',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_L2_NORM
!========================================================================================

SUBROUTINE FIELDS_NORM(SELF,CDGREP,PNORM,KFIDS)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CHARACTER(LEN=*),         INTENT(IN)    :: CDGREP
REAL(KIND=JPRB),          INTENT(OUT)   :: PNORM
INTEGER(KIND=JPIM),OPTIONAL,TARGET,INTENT(IN) :: KFIDS(:)

TYPE(FIELD_ACCESS)  :: YLFAC
REAL(KIND=JPRB) :: ZZ(1),ZMAXVAL_SELF,ZMINVAL_SELF
INTEGER(KIND=JPIM) :: JCOL,JBLK,IKGLO,IST,IEND
INTEGER(KIND=JPIM),POINTER :: IFIDS(:)
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_NORM',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>SELF%GEOM%YRDIM,YDDIMV=>SELF%GEOM%YRDIMV,YDGEM=>SELF%GEOM%YRGEM)
ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA,NGPTOT=>YDGEM%NGPTOT)
IF(PRESENT(KFIDS)) THEN
  IFIDS => KFIDS
ELSE
  IFIDS => SELF%VARS%FIELDIDS
ENDIF
PNORM = 0.0
ZZ = 0.0
ZMAXVAL_SELF = -HUGE(ZMAXVAL_SELF)
ZMINVAL_SELF = HUGE(ZMAXVAL_SELF)
DO JBLK=1,NGPBLKS
  IKGLO = 1+(JBLK-1)*NPROMA
  IST = 1
  IEND = MIN(NPROMA,NGPTOT-IKGLO+1)
  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=IFIDS,KBLOCK=JBLK,FAC=YLFAC) == 1)
    IF(ASSOCIATED(YLFAC%RR1)) THEN
      ZZ(1) = ZZ(1)+DOT_PRODUCT(YLFAC%RR1(IST:IEND),YLFAC%RR1(IST:IEND))
      ZMAXVAL_SELF=MAX(ZMAXVAL_SELF,MAXVAL(YLFAC%RR1(IST:IEND)))
      ZMINVAL_SELF=MIN(ZMINVAL_SELF,MINVAL(YLFAC%RR1(IST:IEND)))
    ELSE
      DO JCOL=1,SIZE(YLFAC%RR2(1,:))
        ZZ(1) = ZZ(1)+DOT_PRODUCT(YLFAC%RR2(IST:IEND,JCOL),YLFAC%RR2(IST:IEND,JCOL))
        ZMAXVAL_SELF=MAX(ZMAXVAL_SELF,MAXVAL(YLFAC%RR2(IST:IEND,JCOL)))
        ZMINVAL_SELF=MIN(ZMINVAL_SELF,MINVAL(YLFAC%RR2(IST:IEND,JCOL)))
      ENDDO
    ENDIF
  ENDDO
ENDDO
PNORM = ORDER_INDEP_GLOBAL_SUM(ZZ,KNG=1)

WRITE(NULOUT,*) CDGREP,PNORM,ZMINVAL_SELF,ZMAXVAL_SELF
CALL FLUSH(NULOUT)
END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_NORM',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_NORM
!==========================================================================================

SUBROUTINE FIELDS_GPNORM(SELF,CDGREP,KFIDS,PMAX,PMIN)
CLASS(FIELDS_BASE),      INTENT(INOUT) :: SELF
CHARACTER(LEN=*),        INTENT(IN)    :: CDGREP
INTEGER(KIND=JPIM),OPTIONAL,TARGET,INTENT(IN) :: KFIDS(:)
REAL(KIND=JPRB),OPTIONAL,INTENT(OUT)   :: PMAX
REAL(KIND=JPRB),OPTIONAL,INTENT(OUT)   :: PMIN

TYPE(FIELD_ACCESS)  :: YLFAC
REAL(KIND=JPRB) :: ZZ(1),ZMAXVAL_SELF,ZMINVAL_SELF
REAL(KIND=JPRB),ALLOCATABLE :: ZMEAN(:),ZMIN(:),ZMAX(:),ZGP(:,:,:),ZZMIN(:,:),ZZMAX(:,:)
REAL(KIND=JPRB),POINTER :: ZFIELD1(:),ZFIELD2(:,:)
INTEGER(KIND=JPIM) :: JCOL,JBLK,IKGLO,IST,IEND,IFIELDS,JFLD,ID,JL,JF,ITH,ITHMAX,IGPNMASTER,ITAG
INTEGER(KIND=JPIM),POINTER :: IFIDS(:)
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_GPNORM',0,ZHOOK_HANDLE)
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_GPNORM',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_GPNORM
!==========================================================================================

SUBROUTINE FIELDS_SCHUR_PROD(SELF,RHS)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CLASS(FIELDS_BASE),       INTENT(INOUT) :: RHS
TYPE(FIELD_ACCESS), POINTER :: YLFAC,YLRHS
INTEGER(KIND=JPIM) :: JCOL,JBLK,ITID,IST,IEND,IBL,JL,IKGLO
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_SCHUR_PROD',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>SELF%GEOM%YRDIM,YDDIMV=>SELF%GEOM%YRDIMV,YDGEM=>SELF%GEOM%YRGEM)
ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA,NGPTOT=>YDGEM%NGPTOT)
IF(.NOT.GEOMETRY_SAME(SELF%GEOM,RHS%GEOM)) CALL ABOR1('FIELDS_BASE_MOD:FIELDS_SCHUR_PROD DIFFERENT RESOLUTION')

!$OMP PARALLEL PRIVATE(JBLK,IKGLO,IST,IEND,YLFAC,YLRHS)
ALLOCATE(YLFAC,YLRHS)
!$OMP DO SCHEDULE(STATIC)
DO JBLK=1,SELF%GEOM%YRDIM%NGPBLKS
  IKGLO = 1+(JBLK-1)*NPROMA
  IST = 1
  IEND = MIN(NPROMA,NGPTOT-IKGLO+1)
  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=SELF%VARS%FIELDIDS,KBLOCK=JBLK,FAC=YLFAC,KOTID=ITID) + &
   & RHS%FIELD%FIELD_ITERATED(KFIDS=SELF%VARS%FIELDIDS,KBLOCK=JBLK,FAC=YLRHS)  == 2)
    IF(ASSOCIATED(YLFAC%RR1)) THEN
      IF(.NOT.ASSOCIATED(YLRHS%RR1)) CALL ABOR1('FIELDS_BASE_MOD:FIELDS_SCHUR_PROD - ZRHS_1D NOT ASSOCIATED')
      YLFAC%RR1(IST:IEND) = YLFAC%RR1(IST:IEND)*YLRHS%RR1(IST:IEND)
    ELSE
      IF(.NOT.ASSOCIATED(YLRHS%RR2)) CALL ABOR1('FIELDS_BASE_MOD:FIELDS_SCHUR_PROD - ZRHS_2D NOT ASSOCIATED')
      DO JCOL=1,SIZE(YLFAC%RR2(1,:))
        YLFAC%RR2(IST:IEND,JCOL) = YLFAC%RR2(IST:IEND,JCOL)*YLRHS%RR2(IST:IEND,JCOL)
      ENDDO
    ENDIF
  ENDDO
ENDDO
!$OMP END DO
DEALLOCATE(YLFAC,YLRHS)
!$OMP END PARALLEL

END ASSOCIATE
END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_SCHUR_PROD',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_SCHUR_PROD
!==========================================================================================

SUBROUTINE FIELDS_ADD_INCR(SELF,RHS)
USE FIELD_CONTAINER_OPER_MOD, ONLY : FIELD_CONTAINER_INTERP,FIELD_CONTAINER_AXPY_SPEC
USE FIELD_DEFINITIONS, ONLY : FID,MAIN_FIELD_METADATA,TYPE_FIELD_ID
USE YOMCT0, ONLY : NINTERPINCR

CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CLASS(FIELDS_BASE),TARGET,INTENT(INOUT) :: RHS
REAL(KIND=JPRB) :: ZZ,ZEPS
TYPE(FIELDS_BASE),TARGET   :: RHS_SELFRES
TYPE(FIELDS_BASE),POINTER  :: RHS_SELFRES_PTR
LOGICAL :: LLSAME_RESOL
INTEGER(KIND=JPIM),POINTER :: IFIDS(:)
INTEGER(KIND=JPIM),ALLOCATABLE :: IFIDS_SPEC(:)
INTEGER(KIND=JPIM) :: IFIDS_POSITIVE(1)
INTEGER(KIND=JPIM),ALLOCATABLE :: IFIDS_GP(:)
REAL(KIND=JPRB), ALLOCATABLE :: ZGPSPGLO(:,:)
TYPE(FIELD_ACCESS) :: YLFAC,YLRHS
TYPE(TYPE_FIELD_ID) :: YLFID
INTEGER(KIND=JPIM) :: JBLK,IST,IEND,IKGLO
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_ADD_INCR',0,ZHOOK_HANDLE)
IF(ASSOCIATED(SELF%VARS%FIELDIDS)) THEN
  IFIDS => SELF%VARS%FIELDIDS
  WRITE(NULOUT,*) 'FIELDS_BASE_MOD:ENTER FIELDS_ADD_INCR FROM SELF',IFIDS(:)
ELSEIF(ASSOCIATED(RHS%VARS%FIELDIDS)) THEN
  IFIDS => RHS%VARS%FIELDIDS
  WRITE(NULOUT,*) 'FIELDS_BASE_MOD:ENTER FIELDS_ADD_INCR FROM RHS',IFIDS(:)
ELSE
  CALL ABOR1('FIELDS_BASE_MOD: FIELDS_ADD_INCR - NO LIST OF VARS')
ENDIF
LLSAME_RESOL = GEOMETRY_SAME(SELF%GEOM,RHS%GEOM)
WRITE(NULOUT,*) 'FIELDS_BASE_MOD:FIELDS_ADD_INCR - LLSAME_RESOL',LLSAME_RESOL
!CALL SELF%FIELDS_GPNORM('FIELDS_ADD_INCR : SELF BEFORE ',KFIDS=IFIDS)
!CALL RHS%FIELDS_GPNORM('FIELDS_ADD_INCR : RHS BEFORE ',KFIDS=IFIDS)
IF(LLSAME_RESOL) THEN
  RHS_SELFRES_PTR => RHS
  ALLOCATE(IFIDS_GP(SIZE(IFIDS)))
  IFIDS_GP(:) = IFIDS(:)
ELSE
  CALL SPLIT_SPEC_GP(IFIDS,IFIDS_SPEC,IFIDS_GP)
  WRITE(NULOUT,*) 'FIELDS_BASE_MOD:FIELDS_ADD_INCR - IFIDS_GP',IFIDS_GP
  CALL FIELD_CONTAINER_AXPY_SPEC(SELF%GEOM,RHS%GEOM,SELF%FIELD,1.0_JPRB,RHS%FIELD,IFIDS_SPEC)
  RHS_SELFRES%GEOM => SELF%GEOM
  RHS_SELFRES%FIELD => RHS_SELFRES%FIELDSTORE
  CALL RHS_SELFRES%FIELD%FIELD_CREATE(MAIN_FIELD_METADATA,RHS_SELFRES%GEOM%YRGEM%NGPTOT, &
   & (/ RHS_SELFRES%GEOM%YRDIMV%NFLEVG, RHS_SELFRES%GEOM%YRDIMV%NFLEVG+1,4,1,1,1,1,1,1,1,1/),&
   & RHS_SELFRES%GEOM%YRDIM%NPROMA,KFIDS=IFIDS_GP)
  CALL RHS_SELFRES%FIELDS_ZEROS
  IF(NINTERPINCR == 1) THEN
    ! Bi-linear interpolation
    CALL FIELD_CONTAINER_INTERP(RHS%GEOM,RHS_SELFRES%GEOM,RHS%FIELD,RHS_SELFRES%FIELD)
  ELSEIF(NINTERPINCR == 3) THEN
    ! Conserving interpolation
    IF(SELF%GEOM%YRDIM%NSMAX < RHS%GEOM%YRDIM%NSMAX) THEN
      ALLOCATE(ZGPSPGLO(RHS%GEOM%YRGEM%NGPTOTG,1))
      CALL RHS%FIELDS_PGPSP(ZGPSPGLO)
    ELSE
      ALLOCATE(ZGPSPGLO(SELF%GEOM%YRGEM%NGPTOTG,1))
      CALL SELF%FIELDS_PGPSP(ZGPSPGLO)
    ENDIF
    CALL FIELD_CONTAINER_INTERP(RHS%GEOM,RHS_SELFRES%GEOM,RHS%FIELD,RHS_SELFRES%FIELD,PGPSPGLO=ZGPSPGLO)
  ELSE
    CALL ABOR1('FIELDS_BASE_MOD: FIELDS_ADD_INCR - INVALID CHOICE OF INTERPOLATION TYPE')
  ENDIF
  RHS_SELFRES_PTR => RHS_SELFRES
ENDIF
IFIDS_POSITIVE(:)=(/YLFID%Q/)
CALL SELF%FIELDS_AXPY(1.0_JPRB,RHS_SELFRES_PTR,KFIDS=IFIDS_GP)

!Temporary security /MH
!ASSOCIATE(YDDIM=>SELF%GEOM%YRDIM,YDGEM=>SELF%GEOM%YRGEM)
!ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, &
! & NGPTOT=>YDGEM%NGPTOT)
!ZEPS=100.0_JPRB*EPSILON(ZEPS)
!DO JBLK=1,NGPBLKS
!  IKGLO = 1+(JBLK-1)*NPROMA
!  IST = 1
!  IEND = MIN(NPROMA,NGPTOT-IKGLO+1)
!  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=IFIDS_GP,KBLOCK=JBLK,FAC=YLFAC) == 1)
!    IF(ASSOCIATED(YLFAC%RR1)) THEN
!      YLFAC%RR1(IST:IEND) = MAX(ZEPS,YLFAC%RR1(IST:IEND))
!    ELSE
!      YLFAC%RR2(IST:IEND,:) = MAX(ZEPS,YLFAC%RR2(IST:IEND,:))
!    ENDIF
!  ENDDO
!ENDDO
!END ASSOCIATE
!END ASSOCIATE

!CALL SELF%FIELDS_GPNORM('FIELDS_ADD_INCR : SELF AFTER ',KFIDS=IFIDS)
RHS_SELFRES_PTR => NULL()

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_ADD_INCR',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_ADD_INCR
!==========================================================================================

SUBROUTINE FIELDS_DIFF_INCR(SELF,X1,X2)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CLASS(FIELDS_BASE),       INTENT(INOUT) :: X1
CLASS(FIELDS_BASE),       INTENT(INOUT) :: X2

INTEGER(KIND=JPIM),POINTER :: IFIDS(:)
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_DIFF_INCR',0,ZHOOK_HANDLE)
IF(ASSOCIATED(SELF%VARS%FIELDIDS)) THEN
  IFIDS => SELF%VARS%FIELDIDS
  WRITE(NULOUT,*) 'FIELDS_BASE_MOD:ENTER FIELDS_DIFF_INCR FROM SELF',IFIDS(:)
ELSE
  CALL ABOR1('FIELDS_BASE_MOD: FIELDS_DIFF_INCR - NO LIST OF VARS')
ENDIF

CALL FIELDS_ZEROS(SELF)
CALL FIELDS_AXPY(SELF,1.0_JPRB,X1,KFIDS=IFIDS,LDSPEC_INT=.TRUE.)
CALL FIELDS_AXPY(SELF,-1.0_JPRB,X2,KFIDS=IFIDS,LDSPEC_INT=.TRUE.)
!CALL FIELDS_COPY(SELF,X1,IFIDS)
!CALL FIELDS_SUB(SELF,X2)

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_DIFF_INCR',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_DIFF_INCR
!==========================================================================================

SUBROUTINE FIELDS_WRITE(SELF,CDFNAME,KFIDS,LDWRITE_SPEC)
USE FIELD_DEFINITIONS     , ONLY : FID, MAIN_FIELD_METADATA
USE FIELD_CONTAINER_SP_MOD, ONLY : FIELD_CONTAINER_SP,TYPE_ITERATOR
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CHARACTER(LEN=*), OPTIONAL, INTENT(IN)  :: CDFNAME
INTEGER(KIND=JPIM),OPTIONAL,TARGET,INTENT(IN) :: KFIDS(:)
LOGICAL,OPTIONAL,INTENT(IN) :: LDWRITE_SPEC

INTEGER(KIND=JPIM),POINTER :: IFIDS(:)
INTEGER(KIND=JPIM),ALLOCATABLE :: IFIDS_GP(:),IFIDS_SPEC(:),IFIDS_GP_REMOVE(:)
INTEGER(KIND=JPIM) :: JFLD,IFIELDS_GP,JF,IST,IEND,ID,IKGLO,JBLK,INLEVS
INTEGER(KIND=JPIM) :: IOPROC,ILOCGRB
INTEGER(KIND=JPIM) :: ILEVS(SELF%GEOM%YRDIMV%NFLEVG),IBSETS(SELF%GEOM%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM) :: JL,IGRIBS(SELF%GEOM%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM),ALLOCATABLE,TARGET :: IACTIVE(:)
REAL(KIND=JPRB),ALLOCATABLE :: ZGP3(:,:,:)
REAL(KIND=JPRB),POINTER :: ZFIELD1(:),ZFIELD2(:,:)
REAL(KIND=JPRB),POINTER :: ZSPEC_1D(:),ZSPEC_2D(:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZSPEC_1D_VEC(:,:),ZSPEC_2D_VEC(:,:,:)
CHARACTER(LEN=64) :: CLFNAME
LOGICAL :: LLMCC04, LLWRITE_SPEC
TYPE(TYPE_IOSTREAM) :: YL_IOSTREAM
TYPE(TYPE_IOREQUEST) :: YL_IOREQUEST
TYPE(TYPE_GRIB_HANDLES) :: YLGBH_SAVE
TYPE(FIELD_CONTAINER_SP) :: YLSPEC
TYPE(TYPE_ITERATOR) :: YLIT
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_WRITE',0,ZHOOK_HANDLE)
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_WRITE',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_WRITE
!==========================================================================================

SUBROUTINE FIELDS_READ(SELF,CDFNAME,KFIDS,LDREAD_SPEC)
USE FIELD_DEFINITIONS     , ONLY : FID, MAIN_FIELD_METADATA
USE FIELD_CONTAINER_SP_MOD, ONLY : FIELD_CONTAINER_SP,TYPE_ITERATOR
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
CHARACTER(LEN=*), OPTIONAL, INTENT(IN)  :: CDFNAME
INTEGER(KIND=JPIM),OPTIONAL,TARGET,INTENT(IN) :: KFIDS(:)
LOGICAL,OPTIONAL,INTENT(IN) :: LDREAD_SPEC

INTEGER(KIND=JPIM),POINTER :: IFIDS(:)
INTEGER(KIND=JPIM),ALLOCATABLE :: IFIDS_GP(:),IFIDS_SPEC(:),IFIDS_GP_REMOVE(:)
INTEGER(KIND=JPIM) :: JFLD,IFIELDS_GP,JF,IST,IEND,ID,IKGLO,JBLK
INTEGER(KIND=JPIM) :: IOPROC,ILOCGRB
INTEGER(KIND=JPIM) :: ILEVS(SELF%GEOM%YRDIMV%NFLEVG),IBSETS(SELF%GEOM%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM) :: JL,IGRIBS(SELF%GEOM%YRDIMV%NFLEVG)
REAL(KIND=JPRB),ALLOCATABLE :: ZGP3(:,:,:)
REAL(KIND=JPRB),POINTER :: ZFIELD1(:),ZFIELD2(:,:)
REAL(KIND=JPRB),POINTER :: ZSPEC_1D(:),ZSPEC_2D(:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZSPEC_1D_VEC(:,:),ZSPEC_2D_VEC(:,:,:)
CHARACTER(LEN=64) :: CLFNAME
LOGICAL :: LLMCC04, LLREAD_SPEC
TYPE(TYPE_IOSTREAM) :: YL_IOSTREAM
TYPE(TYPE_IOREQUEST) :: YL_IOREQUEST
TYPE(TYPE_GRIB_HANDLES) :: YLGBH_SAVE
TYPE(FIELD_CONTAINER_SP) :: YLSPEC
TYPE(TYPE_ITERATOR) :: YLIT
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_READ',0,ZHOOK_HANDLE)
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_READ',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_READ
!==========================================================================================

SUBROUTINE FIELDS_RANDOM(SELF)
CLASS(FIELDS_BASE),       INTENT(INOUT) :: SELF
INTEGER(KIND=JPIM) :: JBLK
TYPE(FIELD_ACCESS)  :: YLFAC
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_RANDOM',0,ZHOOK_HANDLE)
DO JBLK=1,SELF%GEOM%YRDIM%NGPBLKS
  DO WHILE (SELF%FIELD%FIELD_ITERATED(KFIDS=SELF%VARS%FIELDIDS,KBLOCK=JBLK,FAC=YLFAC) == 1)
    IF(ASSOCIATED(YLFAC%RR1)) THEN
      CALL RANDOM_NUMBER(YLFAC%RR1(:))
      YLFAC%RR1(:) = YLFAC%RR1(:) - 0.5_JPRB
    ELSE
      CALL RANDOM_NUMBER(YLFAC%RR2(:,:))
      YLFAC%RR2(:,:) = YLFAC%RR2(:,:) - 0.5_JPRB
    ENDIF
  ENDDO
ENDDO
!CALL SELF%FIELDS_GPNORM('FIELDS_BASE_MOD:EXIT FIELDS_RANDOM')
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_RANDOM',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_RANDOM
!=============================================================================

FUNCTION INTREST(KSOURCE,KREMOVE)

INTEGER(KIND=JPIM),INTENT(IN) :: KSOURCE(:)
INTEGER(KIND=JPIM),INTENT(IN) :: KREMOVE(:)

INTEGER(KIND=JPIM),ALLOCATABLE :: INTREST(:)
INTEGER(KIND=JPIM) :: ITEMP(SIZE(KSOURCE)),INUM,J
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:INTREST',0,ZHOOK_HANDLE)
INUM=0
DO J=1,SIZE(KSOURCE)
  IF(ANY(KREMOVE(:) == KSOURCE(J))) CYCLE
  INUM = INUM+1
  ITEMP(INUM) = KSOURCE(J)
ENDDO
ALLOCATE(INTREST(INUM))
INTREST(:) = ITEMP(1:INUM)
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:INTREST',1,ZHOOK_HANDLE)
END FUNCTION INTREST

!==========================================================================================

SUBROUTINE SPLIT_SPEC_GP(KFIDS,KFIDS_SPEC,KFIDS_GP)
INTEGER(KIND=JPIM),INTENT(IN)  :: KFIDS(:)
INTEGER(KIND=JPIM),ALLOCATABLE,INTENT(OUT) :: KFIDS_SPEC(:)
INTEGER(KIND=JPIM),ALLOCATABLE,INTENT(OUT) :: KFIDS_GP(:)
INTEGER(KIND=JPIM),PARAMETER :: JPMAXLEN=500
INTEGER(KIND=JPIM) :: ISPECREP(4),ISPECTMP(JPMAXLEN),IGPTMP(JPMAXLEN),INSPEC,INGP,J

! This needs to changed for NH model
ISPECREP(:) = (/FID%U,FID%V,FID%T,FID%SP/)
INSPEC = 0
INGP = 0
DO J=1,SIZE(KFIDS)
  IF(ANY(ISPECREP(:) == KFIDS(J))) THEN
    INSPEC = INSPEC+1
    IF(INSPEC > JPMAXLEN) CALL ABOR1('FIELDS_BASE_MOD:SPLIT_SPEC_GP : INSPEC TOO LARGE')
    ISPECTMP(INSPEC) = KFIDS(J)
  ELSE
    INGP = INGP+1
    IF(INGP > JPMAXLEN) CALL ABOR1('FIELDS_BASE_MOD:SPLIT_SPEC_GP : INGP TOO LARGE')
    IGPTMP(INGP) = KFIDS(J)
  ENDIF
ENDDO
IF(INSPEC > 0 .AND. INSPEC /= 4) CALL ABOR1('FIELDS_BASE_MOD:SPLIT_SPEC_GP : ONLY ALL OR NO SPECTRAL FIELDS ALLOWED')
ALLOCATE(KFIDS_SPEC(INSPEC))
ALLOCATE(KFIDS_GP(INGP))
KFIDS_SPEC(:) = ISPECTMP(1:INSPEC)
KFIDS_GP = IGPTMP(1:INGP)

END SUBROUTINE SPLIT_SPEC_GP

!==========================================================================================

SUBROUTINE FIELDS_PGPSP(SELF,PGPSPGLO)
USE FIELD_DEFINITIONS, ONLY : FID
CLASS(FIELDS_BASE), INTENT(INOUT) :: SELF
REAL(KIND=JPRB),    INTENT(INOUT) :: PGPSPGLO(:,:)
INTEGER(KIND=JPIM) :: JBLK, JLOC, IKGLO, IST, IEND, ILOC, IOFFSET
INTEGER(KIND=JPIM), ALLOCATABLE :: IFIELDSPID(:)
REAL(KIND=JPRB), ALLOCATABLE :: ZGPSP(:)
TYPE(FIELD_ACCESS) :: YLFAC
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

! ----------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_PGPSP',0,ZHOOK_HANDLE)
IF (LHOOK) CALL DR_HOOK('FIELDS_BASE_MOD:FIELDS_PGPSP',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_PGPSP
!==========================================================================================

SUBROUTINE FIELDS_BASE_FINAL(THIS)
  TYPE(FIELDS_BASE) :: THIS
  ! If we don't add this, we may get a internal compiler error
  THIS%GEOM => NULL()
  THIS%STATE_MODEL => NULL()
  THIS%FIELD => NULL()
END SUBROUTINE FIELDS_BASE_FINAL

!==========================================================================================

END MODULE FIELDS_BASE_MOD
