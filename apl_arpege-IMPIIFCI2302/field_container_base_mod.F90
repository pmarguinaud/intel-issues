MODULE FIELD_CONTAINER_BASE_MOD 
USE PARKIND1, ONLY: JPIM, JPRB
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK, JPHOOK
USE YOMLUN   , ONLY : NULOUT
USE FIELD_DEFINITIONS_BASE, ONLY: TYPE_FVAR,TYPE_CONTROL, &
  & FIELD_ACCESS_BASE, FIELD_METADATA_BASE
USE FIELD_DEFINITIONS,      ONLY: FIELD_ACCESS,FIELD_METADATA
#ifndef FIELD_MOD_TEST
USE FIELD_GFL_WRAPPER,      ONLY: TGFL_MAP_INTERNAL
#endif
IMPLICIT NONE

PRIVATE

INTEGER(KIND=JPIM), PUBLIC,PARAMETER :: JP_STORAGE1D  = 1 ! basic 1d storage scheme (not rank-conformant at f95)
INTEGER(KIND=JPIM), PUBLIC,PARAMETER :: JP_STORAGE_ARR  = 2 ! "3d" storage scheme preserving rank-conformance
INTEGER(KIND=JPIM), PUBLIC,PARAMETER :: JP_STORAGEOLD = 3 ! backward compatibility: use old gfl, gmvs etc.
TYPE ,PUBLIC :: TYPE_FIELD_INDEX_BASE
  LOGICAL :: L_ON = .FALSE.     ! Requested but possibly pointing to "NUNDEF" in old storage
  LOGICAL :: L_ACTIVE = .FALSE. ! Allocated "active" field
END TYPE TYPE_FIELD_INDEX_BASE
TYPE TYPE_STORAGE_ARRAYS
  REAL(KIND=JPRB),ALLOCATABLE :: STORE1D(:)
  REAL(KIND=JPRB),ALLOCATABLE :: STORE2D(:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: STORE3D(:,:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: STORE4D(:,:,:,:)
END type TYPE_STORAGE_ARRAYS
TYPE, PUBLIC :: TYPE_ITERATOR
INTEGER(KIND=JPIM) :: ICURRENT=0
END type TYPE_ITERATOR

TYPE,PUBLIC :: FIELD_CONTAINER_BASE
!  PRIVATE
  LOGICAL            :: LCREATED=.FALSE.
  INTEGER(KIND=JPIM) :: MSTORTYPE 
  INTEGER(KIND=JPIM) :: M_ATTACH ! If attached to GFLs, what time level?
  INTEGER(KIND=JPIM) :: NFIELDS
  INTEGER(KIND=JPIM) :: NFIELDS_ON
  INTEGER(KIND=JPIM), ALLOCATABLE :: MALL_FIELDS(:)
  TYPE(TYPE_FIELD_INDEX_BASE),ALLOCATABLE:: FIELD_INDEX(:)
  TYPE(TYPE_STORAGE_ARRAYS), ALLOCATABLE       :: STORAGE_ARRAYS(:)
  INTEGER(KIND=JPIM),PRIVATE          :: NLEVELTYPES=0
  INTEGER(KIND=JPIM),PRIVATE          :: NDIM3TYPES=0
  TYPE(TYPE_FVAR), ALLOCATABLE    :: METADATA(:) !=> NULL()
#ifndef FIELD_MOD_TEST
  TYPE(TGFL_MAP_INTERNAL)     :: GFL_MAP_INTERNAL
#endif
  INTEGER(KIND=JPIM)          :: NPOINTS
  INTEGER(KIND=JPIM), ALLOCATABLE:: NLEVELS(:)  ! Number of levels (there will usually be several options)
  INTEGER(KIND=JPIM), ALLOCATABLE:: NDIM3S(:)  ! Third dimesions (there will usually be several options)
  CHARACTER(LEN=3), ALLOCATABLE:: CLEVTYPE(:)  ! IFS level type (SFC or ML) of each field-container level type
  CONTAINS
  PROCEDURE :: FIELD_ACTIVE_CONTAINER
  PROCEDURE :: FIELD_CREATE_BASE
  PROCEDURE :: SETUP_ACTIVE_FIELDS
  PROCEDURE :: ALLOCATE_STORAGE_ARRAYS
  PROCEDURE :: DEALLOCATE_STORAGE_ARRAYS
  PROCEDURE :: GET_STORE_TYPE
  PROCEDURE :: GET_USED_FIELDS
  PROCEDURE :: GET_ACTIVE_FIELDS
END TYPE FIELD_CONTAINER_BASE
CONTAINS
!=======================================================================================
FUNCTION FIELD_ACTIVE_CONTAINER(SELF,KFID)
! ---------------------------------------------------------
! Check whether a container or access type has a particular
! field available
! ---------------------------------------------------------

CLASS(FIELD_CONTAINER_BASE), INTENT(IN) :: SELF
INTEGER(KIND=JPIM),    INTENT(IN) :: KFID
LOGICAL :: FIELD_ACTIVE_CONTAINER
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:FIELD_ACTIVE_CONTAINER',0,ZHOOK_HANDLE)
IF(ALLOCATED(SELF%MALL_FIELDS)) THEN
  FIELD_ACTIVE_CONTAINER = ANY(SELF%MALL_FIELDS == KFID)
ELSE
  FIELD_ACTIVE_CONTAINER = .FALSE.
ENDIF
IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:FIELD_ACTIVE_CONTAINER',1,ZHOOK_HANDLE)

END FUNCTION FIELD_ACTIVE_CONTAINER
!=======================================================================================
SUBROUTINE FIELD_CREATE_BASE(SELF,NAMESPACE,KPOINTS,KLEVELS,KFIDS,KATTACH,KSTORAGE_TYPE,KDIM3S)
CLASS(FIELD_CONTAINER_BASE), INTENT(INOUT) :: SELF
CLASS(FIELD_METADATA_BASE),   INTENT(IN)    :: NAMESPACE  ! Metadata defining what namespace we're using (Main, radiation, etc.)
INTEGER(KIND=JPIM),           INTENT(IN)    :: KPOINTS    ! size per level of field on this PE
INTEGER(KIND=JPIM),           INTENT(IN)    :: KLEVELS(:) ! vertical dimensions 
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: KFIDS(:)    ! list of field IDs (otherwise make all fields)
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: KATTACH     ! Attachment mode (GFL backwards compatibility)
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: KSTORAGE_TYPE
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: KDIM3S(:)
INTEGER(KIND=JPIM) :: JLEVELTYPE
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:FIELD_CREATE_BASE',0,ZHOOK_HANDLE)

SELF%LCREATED = .TRUE.
! Define namespace and metadata
CALL NAMESPACE%FIELD_SET_METADATA(SELF%METADATA,SELF%NLEVELTYPES,SELF%NDIM3TYPES)
IF(SIZE(KLEVELS)/=SELF%NLEVELTYPES) CALL ABOR1('INCONSISTENT LEVEL TYPES IN METADATA')

ALLOCATE(SELF%NLEVELS(SELF%NLEVELTYPES))
SELF%NLEVELS = KLEVELS

IF (ALLOCATED(SELF%CLEVTYPE)) THEN
  DEALLOCATE(SELF%CLEVTYPE)
ENDIF
ALLOCATE(SELF%CLEVTYPE(SELF%NLEVELTYPES))
DO JLEVELTYPE = 1, SELF%NLEVELTYPES
  SELF%CLEVTYPE(JLEVELTYPE) = NAMESPACE%FIELD_GET_CLEVTYPE(JLEVELTYPE)
ENDDO

SELF%NFIELDS = SIZE(SELF%METADATA)
SELF%NPOINTS = KPOINTS
ALLOCATE(SELF%FIELD_INDEX(SELF%NFIELDS))
IF (PRESENT(KATTACH)) THEN
  SELF%MSTORTYPE = JP_STORAGEOLD
ELSE
  IF(PRESENT(KSTORAGE_TYPE)) THEN
     SELF%MSTORTYPE = KSTORAGE_TYPE
   ELSE
     SELF%MSTORTYPE = JP_STORAGE_ARR
   ENDIF
ENDIF
IF (.NOT.ALLOCATED(SELF%NDIM3S)) THEN
  ALLOCATE(SELF%NDIM3S(SELF%NDIM3TYPES))
ELSEIF(SIZE(SELF%NDIM3S) /= SELF%NDIM3TYPES) THEN
  DEALLOCATE(SELF%NDIM3S)
  ALLOCATE(SELF%NDIM3S(SELF%NDIM3TYPES))
ENDIF
IF(PRESENT(KDIM3S)) THEN
  IF(SIZE(KDIM3S)/=SELF%NDIM3TYPES) CALL ABOR1('INCONSISTENT THIRD DIMENSION TYPES IN METADATA')
  SELF%NDIM3S(:) = KDIM3S(:)
ELSE
  SELF%NDIM3S(:) = 0
ENDIF

IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:FIELD_CREATE_BASE',1,ZHOOK_HANDLE)

END SUBROUTINE FIELD_CREATE_BASE
!=======================================================================================
SUBROUTINE SETUP_ACTIVE_FIELDS(SELF,KFIDS)
CLASS(FIELD_CONTAINER_BASE), INTENT(INOUT) :: SELF
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)    :: KFIDS(:)    ! list of field IDs (otherwise make all fields)

INTEGER(KIND=JPIM) :: I,ID
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:SETUP_ACTIVE_FIELDS',0,ZHOOK_HANDLE)

IF (SELF%MSTORTYPE == JP_STORAGE_ARR) THEN
  IF(PRESENT(KFIDS)) THEN
    SELF%NFIELDS_ON = SIZE(KFIDS)
    DO I=1,SELF%NFIELDS_ON
      ID = KFIDS(I)
      SELF%FIELD_INDEX(ID)%L_ON = .TRUE.
      SELF%FIELD_INDEX(ID)%L_ACTIVE = .TRUE.
    ENDDO
  ELSE
    ! Turn on all fields
    SELF%NFIELDS_ON = SELF%NFIELDS
    SELF%FIELD_INDEX(:)%L_ON = .TRUE.
    SELF%FIELD_INDEX(:)%L_ACTIVE = .TRUE.
  ENDIF
  ALLOCATE(SELF%MALL_FIELDS(SELF%NFIELDS_ON))
  IF(PRESENT(KFIDS)) THEN
    SELF%MALL_FIELDS = KFIDS
  ELSE
    DO ID=1,SELF%NFIELDS
      SELF%MALL_FIELDS(ID) = ID 
    ENDDO
  ENDIF
ENDIF

IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:SETUP_ACTIVE_FIELDS',1,ZHOOK_HANDLE)

END SUBROUTINE SETUP_ACTIVE_FIELDS
!=======================================================================================
SUBROUTINE ALLOCATE_STORAGE_ARRAYS(SELF,KPROMA)
CLASS(FIELD_CONTAINER_BASE), INTENT(INOUT) :: SELF
INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN) :: KPROMA
INTEGER(KIND=JPIM) :: ITOTLEVS,ID,INLEVELS,IBLOCKS,INDIM3
LOGICAL :: LLNPROMA
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:ALLOCATE_STORAGE_ARRAYS',0,ZHOOK_HANDLE)
IF(PRESENT(KPROMA)) THEN
  LLNPROMA = .TRUE.
  IBLOCKS = (SELF%NPOINTS-1)/KPROMA+1
ELSE
  LLNPROMA = .FALSE.
ENDIF
ITOTLEVS = 0
ALLOCATE(SELF%STORAGE_ARRAYS(SELF%NFIELDS))
DO ID=1,SELF%NFIELDS
  IF (SELF%FIELD_INDEX(ID)%L_ON) THEN
    IF (SELF%METADATA(ID)%NDIMS == 0) THEN
      INLEVELS = SELF%NLEVELS(SELF%METADATA(ID)%D2TYPE)
      ALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE1D(INLEVELS))
    ELSEIF (SELF%METADATA(ID)%NDIMS == 1) THEN
      INLEVELS = 1 
      IF(LLNPROMA) THEN
        ALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE2D(KPROMA,IBLOCKS))
      ELSE
        ALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE1D(SELF%NPOINTS))
      ENDIF
    ELSEIF (SELF%METADATA(ID)%NDIMS == 2) THEN
      INLEVELS = SELF%NLEVELS(SELF%METADATA(ID)%D2TYPE)
      IF(LLNPROMA) THEN
        ALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE3D(KPROMA,INLEVELS,IBLOCKS))
      ELSE
        ALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE2D(INLEVELS,SELF%NPOINTS))
      ENDIF
    ELSEIF (SELF%METADATA(ID)%NDIMS == 3) THEN
      INLEVELS = SELF%NLEVELS(SELF%METADATA(ID)%D2TYPE) 
      INDIM3   = SELF%NDIM3S(SELF%METADATA(ID)%D3TYPE)
      IF(LLNPROMA) THEN
         ALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE4D(KPROMA,INLEVELS,INDIM3,IBLOCKS))
      ELSE
        ALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE3D(INLEVELS,SELF%NPOINTS,INDIM3))
      ENDIF
    ENDIF
    ITOTLEVS = ITOTLEVS+INLEVELS
  ENDIF
ENDDO
IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:ALLOCATE_STORAGE_ARRAYS',1,ZHOOK_HANDLE)

END SUBROUTINE ALLOCATE_STORAGE_ARRAYS
!=======================================================================================
SUBROUTINE DEALLOCATE_STORAGE_ARRAYS(SELF)
CLASS(FIELD_CONTAINER_BASE), INTENT(INOUT) :: SELF
INTEGER(KIND=JPIM) :: ID
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:DEALLOCATE_STORAGE_ARRAYS',0,ZHOOK_HANDLE)
DO ID=1,SELF%NFIELDS
  IF(ALLOCATED(SELF%STORAGE_ARRAYS(ID)%STORE1D)) DEALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE1D)
  IF(ALLOCATED(SELF%STORAGE_ARRAYS(ID)%STORE2D)) DEALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE2D)
  IF(ALLOCATED(SELF%STORAGE_ARRAYS(ID)%STORE3D)) DEALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE3D)
  IF(ALLOCATED(SELF%STORAGE_ARRAYS(ID)%STORE4D)) DEALLOCATE(SELF%STORAGE_ARRAYS(ID)%STORE4D)
ENDDO
DEALLOCATE(SELF%STORAGE_ARRAYS)
IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:DEALLOCATE_STORAGE_ARRAYS',1,ZHOOK_HANDLE)

END SUBROUTINE DEALLOCATE_STORAGE_ARRAYS
!=======================================================================================
FUNCTION GET_STORE_TYPE(SELF)
CLASS(FIELD_CONTAINER_BASE), INTENT(IN) :: SELF
INTEGER(KIND=JPIM) :: GET_STORE_TYPE
REAL(KIND=JPHOOK)  :: ZHOOK_HANDLE

GET_STORE_TYPE = SELF%MSTORTYPE
END FUNCTION GET_STORE_TYPE

!=======================================================================================
SUBROUTINE GET_USED_FIELDS(SELF,KUSED_FIELDS,KFIDS)
CLASS(FIELD_CONTAINER_BASE), INTENT(IN) :: SELF
INTEGER(KIND=JPIM),ALLOCATABLE,INTENT(OUT) :: KUSED_FIELDS(:)
INTEGER(KIND=JPIM), TARGET, OPTIONAL,INTENT(IN) :: KFIDS(:) 
INTEGER(KIND=JPIM) :: IFIELDS_USED,ID,J,IUSED_FIDS(SELF%NFIELDS)
LOGICAL :: LLON
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:GET_USED_FIELDS',0,ZHOOK_HANDLE)
IFIELDS_USED = 0
DO ID=1,SELF%NFIELDS
  LLON = .FALSE.
  IF (SELF%FIELD_INDEX(ID)%L_ON) THEN
    IF (PRESENT(KFIDS)) THEN
      IF (ANY(ID==KFIDS)) THEN
        LLON = .TRUE.
      ENDIF
    ELSE
      LLON = .TRUE.
    ENDIF
  ENDIF

  IF(LLON) THEN
    IFIELDS_USED = IFIELDS_USED + 1
    IUSED_FIDS(IFIELDS_USED) = ID
  ENDIF

ENDDO
ALLOCATE(KUSED_FIELDS(IFIELDS_USED))
KUSED_FIELDS(:) = IUSED_FIDS(1:IFIELDS_USED)
IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:GET_USED_FIELDS',1,ZHOOK_HANDLE)

END SUBROUTINE GET_USED_FIELDS
!=======================================================================================

SUBROUTINE GET_ACTIVE_FIELDS(SELF,KACTIVE_FIELDS,KFIDS)
CLASS(FIELD_CONTAINER_BASE), INTENT(IN) :: SELF
INTEGER(KIND=JPIM),ALLOCATABLE,INTENT(OUT) :: KACTIVE_FIELDS(:)
INTEGER(KIND=JPIM), TARGET, OPTIONAL,INTENT(IN) :: KFIDS(:) 
INTEGER(KIND=JPIM) :: IFIELDS_ACTIVE,ID,J,IACTIVE_FIDS(SELF%NFIELDS)
LOGICAL :: LLACTIVE
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:GET_ACTIVE_FIELDS',0,ZHOOK_HANDLE)
IFIELDS_ACTIVE = 0
DO ID=1,SELF%NFIELDS
  LLACTIVE = .FALSE.
  IF (SELF%FIELD_INDEX(ID)%L_ACTIVE) THEN
    IF (PRESENT(KFIDS)) THEN
      IF (ANY(ID==KFIDS)) THEN
        LLACTIVE = .TRUE.
      ENDIF
    ELSE
      LLACTIVE = .TRUE.
    ENDIF
  ENDIF

  IF(LLACTIVE) THEN
    IFIELDS_ACTIVE = IFIELDS_ACTIVE + 1
    IACTIVE_FIDS(IFIELDS_ACTIVE) = ID
  ENDIF

ENDDO
ALLOCATE(KACTIVE_FIELDS(IFIELDS_ACTIVE))
KACTIVE_FIELDS(:) = IACTIVE_FIDS(1:IFIELDS_ACTIVE)
IF (LHOOK) CALL DR_HOOK('FIELD_CONTAINER_BASE_MOD:GET_ACTIVE_FIELDS',1,ZHOOK_HANDLE)

END SUBROUTINE GET_ACTIVE_FIELDS

!=======================================================================================
END MODULE FIELD_CONTAINER_BASE_MOD
