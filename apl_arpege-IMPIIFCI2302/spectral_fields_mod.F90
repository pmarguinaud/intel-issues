MODULE SPECTRAL_FIELDS_MOD

!   Author.
!   -------
!     Yannick Tremolet
!
!   Modifications.
!   --------------
!     Original    02-03-05
!     Y.Tremolet  02-07-25 Added operators.
!     C.Fischer   03-03-03 Aladin spectral treatment added.
!      N.B.1: the mean wind spec%sp1d is treated in assign_sp_sp and in
!             assign_scalar_sp but not in assign_ar_sp and assign_sp_ar.
!             therefore, whenever a fortran array is copied to a spectral_field
!             type in Aladin, one should take care of the mean wind externally.
!             see for example get_cv_init and set_cv_init in control_vectors.F90.
!     Y.Tremolet  11-Mar-2004 Type definition moved to SPECTRAL_FIELDS_DATA.
!     Y.Tremolet  11-Mar-2004 SPECTRAL_FIELDS_PARA_MOD for distributed operators.
!     Y.Tremolet  22-Jul-2004 SPECTRAL_FIELDS_OPER_MOD for basic operators.
!     M.Fisher    23-Aug-2004 Added RANDOM_SPECTRAL_FIELD
!     C. Fischer  20-May-2005 RANDOM_SPECTRAL_FIELD updated for Aladin
!     M. Fisher   7-March-2012 Use DEALLOCATE_IF_ASSOCIATED
!     R. El Khatib 08-Jul-2014 Optional argument kpsurf to create_spec, mandatory to copy_spec
!     M. Chrust   3-Jan-2020 Add public SELF_AXPY
! ------------------------------------------------------------------

USE PARKIND1, ONLY: JPIM, JPRB
USE YOMHOOK , ONLY : LHOOK, DR_HOOK, JPHOOK
USE GEOMETRY_MOD, ONLY: GEOMETRY
USE SPECTRAL_VARIABLES_MOD, ONLY: SPECTRAL_VARIABLES
USE SPECTRAL_FIELDS_DATA, ONLY: SPECTRAL_FIELD, &
                              & NPRTRV, NPRTRW, MYSETV, MYSETW, LELAM, NULOUT, &
                              & NGRBVO,NGRBD,NGRBT,NGRBQ,NGRBO3,NGRBLNSP, NGRBZ, &
                              & NGRBCLWC, NGRBCIWC, NGRB118, NGRB119, NGRBNHX
USE SPECTRAL_FIELDS_OPER_MOD, ONLY: ASSIGNMENT(=), OPERATOR(.EQV.), OPERATOR(.NEQV.), &
                              & SELF_ADD, SELF_SUB, SELF_MUL, SELF_AXPY
USE SPECTRAL_FIELDS_PARA_MOD, ONLY: DOT_PRODUCT, SPECTRAL_NORM, &
                              & SPECTRAL_NORM_LEVS, SPECTRAL_MAX_LEVS

IMPLICIT NONE
PRIVATE
PUBLIC SPECTRAL_FIELD, SETUP_SPEC, ALLOCATE_SPEC, DEALLOCATE_SPEC, &
     & ALLOCATED_SPEC, SPECTRAL_DUMMY2D, SPECTRAL_DUMMY3D, SPECTRAL_DUMMY4D, &
     & ASSIGNMENT(=), OPERATOR(.EQV.), OPERATOR(.NEQV.), &
     & SELF_ADD, SELF_SUB, SELF_MUL, SELF_AXPY, INQ_SPEC,  RANDOM_SPECTRAL_FIELD, &
     & DOT_PRODUCT, SPECTRAL_NORM, SPECTRAL_NORM_LEVS, SPECTRAL_MAX_LEVS, &
     &  CREATE_SPEC, ALLOC_SPEC

REAL(KIND=JPRB), TARGET :: SPECTRAL_DUMMY2D (1), SPECTRAL_DUMMY3D (1,1), SPECTRAL_DUMMY4D (1,1,1)
SAVE

! ------------------------------------------------------------------

INTERFACE ALLOCATE_SPEC
MODULE PROCEDURE CREATE_SPEC, CREATE_COPY, ALLOC_SPEC
END INTERFACE

! ------------------------------------------------------------------
CONTAINS
! ------------------------------------------------------------------

SUBROUTINE SETUP_SPEC(KPRTRV,KPRTRW,KSETV,KSETW,LDLAM,KULOUT, &
                    & KGRBVO,KGRBD,KGRBT,KGRBQ,KGRBO3,KGRBLNSP,KGRBZ, &
                    & KGRBCLWC,KGRBCIWC,KGRB118,KGRB119,KGRBNHX)


! This is a way to get values from ifs to ifsaux

INTEGER(KIND=JPIM), INTENT(IN) :: KPRTRV,KPRTRW,KSETV,KSETW, &
              & KULOUT,KGRBVO,KGRBD,KGRBT,KGRBQ,KGRBO3,KGRBLNSP,KGRBZ, &
              & KGRBCLWC,KGRBCIWC,KGRB118,KGRB119,KGRBNHX
LOGICAL, INTENT(IN) :: LDLAM

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:SETUP_SPEC',0,ZHOOK_HANDLE)
LELAM=LDLAM

NPRTRV=KPRTRV
NPRTRW=KPRTRW
MYSETV=KSETV
MYSETW=KSETW
NULOUT=KULOUT
NGRBVO=KGRBVO
NGRBD =KGRBD
NGRBT =KGRBT
NGRBQ =KGRBQ
NGRBO3=KGRBO3
NGRBLNSP=KGRBLNSP
NGRBZ=KGRBZ
NGRBCLWC=KGRBCLWC
NGRBCIWC=KGRBCIWC
NGRB118=KGRB118
NGRB119=KGRB119
NGRBNHX=KGRBNHX

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:SETUP_SPEC',1,ZHOOK_HANDLE)
END SUBROUTINE SETUP_SPEC

! ------------------------------------------------------------------

SUBROUTINE ALLOC_SPEC(YDSP, YDGEOM, YDVAR)
IMPLICIT NONE
TYPE(SPECTRAL_FIELD), TARGET, INTENT(INOUT) :: YDSP
TYPE(GEOMETRY), INTENT(IN) :: YDGEOM
TYPE(SPECTRAL_VARIABLES), INTENT(IN) :: YDVAR
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:ALLOC_SPEC',0,ZHOOK_HANDLE)

CALL CREATE_SPEC(YDSP, &
               & YDGEOM%YRDIMV%NFLEVL, YDGEOM%YRDIMV%NFLEVG, &
               & YDGEOM%YRDIM%NUMP, YDGEOM%YRLAP%MYMS, &
               & YDGEOM%YRDIM%NSMAX, YDGEOM%YRDIM%NMSMAX, &
               & YDGEOM%YRMP%NALLMS, YDGEOM%YRMP%NPTRMS, YDGEOM%YRMP%NUMLL, &
               & YDGEOM%YRMP%NPTRLL, YDGEOM%YRMP%NPSURF, &
               & YDVAR%NS3D, YDVAR%NS2D, YDVAR%NGRBVAR)

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:ALLOC_SPEC',1,ZHOOK_HANDLE)
END SUBROUTINE ALLOC_SPEC

! ------------------------------------------------------------------

SUBROUTINE CREATE_SPEC(YDSP, KFLEVL, KFLEVG, KNUMP, KMYMS, KSMAX, KMSMAX, &
 & KALLMS, KPTRMS, KNUMLL, KPTRLL, KPSURF, KS3D, KS2D, KGRIB)

IMPLICIT NONE
TYPE (SPECTRAL_FIELD), TARGET, INTENT(INOUT) :: YDSP
INTEGER(KIND=JPIM), INTENT(IN) :: KFLEVL, KFLEVG, KNUMP, KMYMS(KNUMP), KSMAX, KMSMAX
INTEGER(KIND=JPIM), INTENT(IN) :: KALLMS(:)
INTEGER(KIND=JPIM), INTENT(IN) :: KPTRMS(NPRTRW)
INTEGER(KIND=JPIM), INTENT(IN) :: KNUMLL(NPRTRV), KPTRLL(NPRTRV), KPSURF(NPRTRV)
INTEGER(KIND=JPIM), INTENT(IN) :: KS3D, KS2D, KGRIB(KS3D+KS2D)

INTEGER(KIND=JPIM) :: IDUM1,IDUM2(0:KSMAX),IDUM3,IDUM4, &
           & IDUM5(NPRTRW+1),IDUM6(0:KSMAX),JP,JM,IMAXMS, &
           & IMDIM,IL,IK,IND,IPOS,IKM,ISC3
INTEGER(KIND=JPIM) :: IPT, ITHER, IGFL, JJ, JPT, JL
INTEGER(KIND=JPIM) :: IKNTMP(0:KMSMAX),IKMTMP(0:KSMAX),ICPL4M(0:KMSMAX)
LOGICAL :: LLMISSING
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:CREATE_SPEC',0,ZHOOK_HANDLE)

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:CREATE_SPEC',1,ZHOOK_HANDLE)

CONTAINS
  INTEGER(KIND=JPIM) FUNCTION INTLOC(KINDX,KVAL)
  INTEGER(KIND=JPIM), INTENT(IN) :: KINDX(:),KVAL
  INTEGER(KIND=JPIM) :: II,JJ
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
  IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:INTLOC',0,ZHOOK_HANDLE)
  JJ=0
  II=1
  DO WHILE (II<=SIZE(KINDX) .AND. JJ==0)
    IF (KINDX(II)==KVAL) JJ=II
    II=II+1
  ENDDO
  INTLOC=JJ
  IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:INTLOC',1,ZHOOK_HANDLE)
  END FUNCTION INTLOC
END SUBROUTINE CREATE_SPEC

! ------------------------------------------------------------------

SUBROUTINE CREATE_COPY(YDSELF, YDOTHER)

TYPE(SPECTRAL_FIELD), INTENT(INOUT) :: YDSELF
TYPE(SPECTRAL_FIELD), INTENT(IN)    :: YDOTHER
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:CREATE_COPY',0,ZHOOK_HANDLE)

CALL CREATE_SPEC(YDSELF, YDOTHER%NFLEVL, YDOTHER%NFLEVG, YDOTHER%NUMP, &
 & YDOTHER%MYMS, YDOTHER%NSMAX, YDOTHER%NMSMAX, YDOTHER%NALLMS, &
 & YDOTHER%NPTRMS, YDOTHER%NUMLL, YDOTHER%NPTRLL, YDOTHER%NPSURF, &
 & YDOTHER%NS3D, YDOTHER%NS2G, YDOTHER%NGRIB)

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:CREATE_COPY',1,ZHOOK_HANDLE)

END SUBROUTINE CREATE_COPY

! ------------------------------------------------------------------

LOGICAL FUNCTION ALLOCATED_SPEC (YDSP)
  TYPE (SPECTRAL_FIELD), INTENT(IN) :: YDSP
  ALLOCATED_SPEC = ALLOCATED(YDSP%SP2D)
END FUNCTION ALLOCATED_SPEC

! ------------------------------------------------------------------

SUBROUTINE DEALLOCATE_SPEC(YDSP)

TYPE (SPECTRAL_FIELD), INTENT(INOUT) :: YDSP
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:DEALLOCATE_SPEC',0,ZHOOK_HANDLE)

NULLIFY(YDSP%VOR)
NULLIFY(YDSP%DIV)
NULLIFY(YDSP%T)
NULLIFY(YDSP%Q)
NULLIFY(YDSP%O3)
NULLIFY(YDSP%L)
NULLIFY(YDSP%I)
NULLIFY(YDSP%SPD)
NULLIFY(YDSP%SVD)
NULLIFY(YDSP%NHX)
NULLIFY(YDSP%SCAL)
NULLIFY(YDSP%HV)
NULLIFY(YDSP%GFL)
NULLIFY(YDSP%SP)
NULLIFY(YDSP%OROG)
NULLIFY(YDSP%UB)
NULLIFY(YDSP%VB)
NULLIFY(YDSP%NGRIB2)
NULLIFY(YDSP%NGRIB3)

IF (ALLOCATED(YDSP%SP2D   )) DEALLOCATE(YDSP%SP2D   )
IF (ALLOCATED(YDSP%SP3D   )) DEALLOCATE(YDSP%SP3D   )
IF (ALLOCATED(YDSP%SP1D   )) DEALLOCATE(YDSP%SP1D   )
IF (ALLOCATED(YDSP%NASM0  )) DEALLOCATE(YDSP%NASM0  )
IF (ALLOCATED(YDSP%NASM0G )) DEALLOCATE(YDSP%NASM0G )
IF (ALLOCATED(YDSP%NESM0  )) DEALLOCATE(YDSP%NESM0  )
IF (ALLOCATED(YDSP%NESM0G )) DEALLOCATE(YDSP%NESM0G )
IF (ALLOCATED(YDSP%NCPL4M )) DEALLOCATE(YDSP%NCPL4M )
IF (ALLOCATED(YDSP%NUMPP  )) DEALLOCATE(YDSP%NUMPP  )
IF (ALLOCATED(YDSP%MS_PROC)) DEALLOCATE(YDSP%MS_PROC)
IF (ALLOCATED(YDSP%NUMLL  )) DEALLOCATE(YDSP%NUMLL  )
IF (ALLOCATED(YDSP%NPTRLL )) DEALLOCATE(YDSP%NPTRLL )
IF (ALLOCATED(YDSP%NPSURF )) DEALLOCATE(YDSP%NPSURF )
IF (ALLOCATED(YDSP%NS2L   )) DEALLOCATE(YDSP%NS2L   )
IF (ALLOCATED(YDSP%NGRIB  )) DEALLOCATE(YDSP%NGRIB  )
IF (ALLOCATED(YDSP%MYMS   )) DEALLOCATE(YDSP%MYMS   )
IF (ALLOCATED(YDSP%MYLEVS )) DEALLOCATE(YDSP%MYLEVS )
IF (ALLOCATED(YDSP%NALLMS )) DEALLOCATE(YDSP%NALLMS )
IF (ALLOCATED(YDSP%NPTRMS )) DEALLOCATE(YDSP%NPTRMS )

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:DEALLOCATE_SPEC',1,ZHOOK_HANDLE)
END SUBROUTINE DEALLOCATE_SPEC

! ------------------------------------------------------------------

SUBROUTINE INQ_SPEC(YDSP, KFLEVL, KFLEVG, KNUMP, KMYMS, KSMAX, KMSMAX, &
 & KALLMS, KPTRMS, KNUMLL, KPTRLL, KPSURF, KS3D, KS2D)

USE PARKIND1, ONLY: JPIM, JPRB
USE YOMHOOK , ONLY : LHOOK, DR_HOOK, JPHOOK
USE SPECTRAL_FIELDS_DATA, ONLY: SPECTRAL_FIELD, NPRTRV, NPRTRW, LELAM, MYSETV, MYSETW

! Sets all indices as allocate_spec without allocating
! space for data.

TYPE (SPECTRAL_FIELD), INTENT(OUT) :: YDSP
INTEGER(KIND=JPIM), INTENT(IN) :: KFLEVL, KFLEVG, KNUMP, KMYMS(KNUMP), KSMAX, KMSMAX
INTEGER(KIND=JPIM), INTENT(IN) :: KALLMS(:)
INTEGER(KIND=JPIM), INTENT(IN) :: KPTRMS(NPRTRW)
INTEGER(KIND=JPIM), INTENT(IN) :: KNUMLL(NPRTRV), KPTRLL(NPRTRV), KPSURF(NPRTRV)
INTEGER(KIND=JPIM), INTENT(IN) :: KS3D, KS2D

INTEGER(KIND=JPIM) :: IDUM1,IDUM2(0:KSMAX),IDUM3,IDUM4,&
           & IDUM5(NPRTRW+1),IDUM6(0:KSMAX),JP,JM,IMAXMS,&
           & IMDIM,IL,IK,IND,IPOS,IKM,JL
INTEGER(KIND=JPIM) :: IKNTMP(0:KMSMAX),IKMTMP(0:KSMAX),ICPL4M(0:KMSMAX)
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:INQ_SPEC',0,ZHOOK_HANDLE)

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:INQ_SPEC',1,ZHOOK_HANDLE)
END SUBROUTINE INQ_SPEC

! ------------------------------------------------------------------

SUBROUTINE RANDOM_SPECTRAL_FIELD (SPEC,KSEED)

!--- Sets the elements of 'spec' to random, unit gaussian values.

!--- NB: There is no normalization by the square-root of the spectral norm.

!--- NB: All seeds in the range kseed to kseed+spec%nsmax are used. On return,
!---     KSEED is incremented by (spec%nsmax+1), so that a subsequent call to
!---     random_spectral_field will use a new set of seeds.

USE RANDOM_NUMBERS_MIX

TYPE (SPECTRAL_FIELD), INTENT(INOUT) :: SPEC
INTEGER(KIND=JPIM), INTENT(INOUT) :: KSEED

INTEGER(KIND=JPIM) :: II,IM,IOFF,IL,JF,JM,JS,JN,JIR,JL,LEN,ISEED
REAL(KIND=JPRB), ALLOCATABLE :: ZTMP(:)
TYPE(RANDOMNUMBERSTREAM), ALLOCATABLE :: YL_RANDOM_STREAM(:)


REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:RANDOM_SPECTRAL_FIELD',0,ZHOOK_HANDLE)
ALLOCATE(YL_RANDOM_STREAM(SPEC%NUMP))

!$OMP PARALLEL DO SCHEDULE(DYNAMIC) PRIVATE(JM,IM,JS,LEN,ISEED,JF,JN,JIR,JL,IL,IOFF,ZTMP)
DO JM=1,SPEC%NUMP
  IM=SPEC%MYMS(JM)

  IF (.NOT.LELAM) THEN
    JS =SPEC%NASM0 (IM)-1
    LEN=2*(SPEC%NSMAX-IM+1)
  ELSE
    JS =SPEC%NESM0 (IM)-1
    LEN=SPEC%NCPL4M(IM)
  ENDIF

  ALLOCATE (ZTMP(LEN*(SPEC%NS3D*SPEC%NFLEVG+SPEC%NS2D)))
  ISEED=KSEED+IM
  CALL INITIALIZE_RANDOM_NUMBERS (ISEED,YL_RANDOM_STREAM(JM))
  CALL GAUSSIAN_DISTRIBUTION (ZTMP,YL_RANDOM_STREAM(JM))

  DO JF=1,SPEC%NS2D
    IOFF=SPEC%NS3D*SPEC%NFLEVG+JF-1
    SPEC%SP2D(JS+1:JS+LEN,JF)=ZTMP(IOFF+1:IOFF+LEN)
  ENDDO

  IF (.NOT.LELAM) THEN
    DO JN=IM,SPEC%NSMAX
      DO JIR=0,1
        JS =SPEC%NASM0 (IM)+(JN-IM)*2+JIR
        DO JF=1,SPEC%NS3D
          DO JL=1,SPEC%NFLEVL
            IL=SPEC%MYLEVS(JL)
            SPEC%SP3D(JL,JS,JF)=ZTMP(JS-SPEC%NASM0(IM)+1+LEN*(IL+SPEC%NFLEVG*(JF-1)))
          ENDDO
        ENDDO
      ENDDO
    ENDDO
  ELSE
    JS =SPEC%NESM0 (IM)-1  ! Repeated for LAM since "js" is recomputed for IFS
    DO JF=1,SPEC%NS3D
      DO JL=1,SPEC%NFLEVL
        IL=SPEC%MYLEVS(JL)
        SPEC%SP3D(JL,JS+1:JS+LEN,JF)=&
    & ZTMP(1+LEN*(IL-1+SPEC%NFLEVG*(JF-1)):&
    & LEN+LEN*(IL-1+SPEC%NFLEVG*(JF-1)))
      ENDDO
    ENDDO
  ENDIF
  DEALLOCATE(ZTMP)
ENDDO
!OMP END PARALLEL DO

DEALLOCATE(YL_RANDOM_STREAM)

IF (.NOT.LELAM) THEN
   KSEED=KSEED+(1+SPEC%NSMAX)
ELSE
   KSEED=KSEED+(1+SPEC%NMSMAX)
ENDIF

IF (LELAM) THEN

!cf DO YOU WANT A RANDOM MEAN WIND COMPONENT, OR ZERO? -> I want it, thanks for asking !

  ALLOCATE(YL_RANDOM_STREAM(1))
  ALLOCATE (ZTMP(SPEC%NS1D*SPEC%NFLEVG))

  CALL INITIALIZE_RANDOM_NUMBERS (KSEED,YL_RANDOM_STREAM(1))
  CALL GAUSSIAN_DISTRIBUTION (ZTMP,YL_RANDOM_STREAM(1))
  KSEED=KSEED+1

  DO JF=1,SPEC%NS1D
    DO JL=1,SPEC%NFLEVL
      IL=SPEC%MYLEVS(JL)
      SPEC%SP1D(JL,JF)=ZTMP(IL+SPEC%NFLEVG*(JF-1))
    ENDDO
  ENDDO
  DEALLOCATE(ZTMP)
ENDIF


IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_MOD:RANDOM_SPECTRAL_FIELD',1,ZHOOK_HANDLE)
END SUBROUTINE RANDOM_SPECTRAL_FIELD

! ------------------------------------------------------------------

END MODULE SPECTRAL_FIELDS_MOD

