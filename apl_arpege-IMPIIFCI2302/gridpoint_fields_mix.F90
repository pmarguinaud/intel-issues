MODULE GRIDPOINT_FIELDS_MIX

!   Purpose
!   -------
!     Flexible data structure to handle grid point fields.

!   Author
!   ------
!     Yannick Tremolet

!   Modifications
!   -------------
!     Original    16-Jan-04
!     M. Fisher   7-March-2012 Use DEALLOCATE_IF_ASSOCIATED
!     M. Chrust   3-Jan-2020 Implement SELF_AXPY, DOT_PRODUCT
! ------------------------------------------------------------------

USE PARKIND1, ONLY: JPIM, JPRB
USE YOMHOOK , ONLY: LHOOK, DR_HOOK, JPHOOK

IMPLICIT NONE
SAVE
PRIVATE
PUBLIC GRIDPOINT_FIELD, ALLOCATE_GRID, DEALLOCATE_GRID, ASSIGNMENT(=), &
     & SELF_ADD, SELF_SUB, SELF_MUL, SELF_AXPY, HUGIFY_ENDGRID, CLIP_GRID, &
     & DOT_PRODUCT

! ------------------------------------------------------------------

! There could be a type GRIDPOINT_STRUCT similar to what Mike has
! done in yomwavlet and a pointer to a GRIDPOINT_STRUCT in the
! GRIDPOINT_FIELD type.

TYPE GRIDPOINT_FIELD
  REAL(KIND=JPRB), POINTER :: GP3D(:,:,:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: GP2D(:,:,:)=>NULL()
  INTEGER(KIND=JPIM) :: NG3D
  INTEGER(KIND=JPIM) :: NG2D
  INTEGER(KIND=JPIM) :: NPROMA
  INTEGER(KIND=JPIM) :: NGPBLKS
  INTEGER(KIND=JPIM) :: NFLEVG
  INTEGER(KIND=JPIM) :: NGPTOT
  INTEGER(KIND=JPIM) :: NGPTOTG
  INTEGER(KIND=JPIM), POINTER :: NGRIB(:)=>NULL(), NGRIB2(:)=>NULL(), NGRIB3(:)=>NULL()
  INTEGER(KIND=JPIM), POINTER :: NPARAMID(:)=>NULL(), NPARAMID2(:)=>NULL(), NPARAMID3(:)=>NULL()
  REAL(KIND=JPRB), POINTER :: DIV(:,:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: VOR(:,:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: U(:,:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: V(:,:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: T(:,:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: Q(:,:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: O3(:,:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: SPR(:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: WIND(:,:,:,:)=>NULL()
  REAL(KIND=JPRB), POINTER :: SCAL(:,:,:,:)=>NULL()
END TYPE GRIDPOINT_FIELD

! ------------------------------------------------------------------

INTERFACE ASSIGNMENT (=)
MODULE PROCEDURE ASSIGN_GP_GP, ASSIGN_SCALAR_GP
END INTERFACE

INTERFACE OPERATOR (.EQV.)
MODULE PROCEDURE EQUIV_GRID
END INTERFACE

INTERFACE OPERATOR (.NEQV.)
MODULE PROCEDURE NEQUIV_GRID
END INTERFACE

INTERFACE SELF_ADD  ! What we really want here is ASSIGNMENT (+=)
MODULE PROCEDURE SELF_ADD_GP, SELF_ADD_SCAL
END INTERFACE

INTERFACE SELF_SUB  ! What we really want here is ASSIGNMENT (-=)
MODULE PROCEDURE SELF_SUB_GP
END INTERFACE

INTERFACE SELF_MUL  ! What we really want here is ASSIGNMENT (*=)
MODULE PROCEDURE SELF_MUL_GP, SELF_MUL_SCAL
END INTERFACE

INTERFACE SELF_AXPY
MODULE PROCEDURE SELF_AXPY_GP
END INTERFACE

INTERFACE DOT_PRODUCT
MODULE PROCEDURE DOT_PRODUCT_GP
END INTERFACE

! ------------------------------------------------------------------
#include "abor1.intfb.h"
! ------------------------------------------------------------------
CONTAINS
! ------------------------------------------------------------------

SUBROUTINE ALLOCATE_GRID(YDGEOMETRY,YDGRID,KG3D,KG2D,KGRIB,KPARAMID)
USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOM_GRIB_CODES , ONLY: NGRBD, NGRBVO, NGRBU, NGRBV, NGRBT, NGRBQ, NGRBO3, NGRBLNSP
USE INDEXFIND_MOD, ONLY: INDXFIND

TYPE(GEOMETRY)        ,INTENT(IN)    :: YDGEOMETRY
TYPE (GRIDPOINT_FIELD),INTENT(OUT)   :: YDGRID
INTEGER(KIND=JPIM)    ,INTENT(IN)    :: KG3D, KG2D, KGRIB(KG3D+KG2D)
INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN) :: KPARAMID(KG3D+KG2D)
INTEGER(KIND=JPIM) :: INDD, INDV, INDT, INDU, INDW, INDQ, INDO, INDS, IWIND
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:ALLOCATE_GRID',0,ZHOOK_HANDLE)

YDGRID%NG3D=KG3D
YDGRID%NG2D=KG2D
YDGRID%NPROMA =YDGEOMETRY%YRDIM%NPROMA
YDGRID%NGPBLKS=YDGEOMETRY%YRDIM%NGPBLKS
YDGRID%NFLEVG =YDGEOMETRY%YRDIMV%NFLEVG
YDGRID%NGPTOT =YDGEOMETRY%YRGEM%NGPTOT
YDGRID%NGPTOTG=YDGEOMETRY%YRGEM%NGPTOTG
ALLOCATE(YDGRID%NGRIB(KG3D+KG2D))
ALLOCATE(YDGRID%NPARAMID(KG3D+KG2D))
YDGRID%NGRIB(:)=KGRIB(:)
IF(PRESENT(KPARAMID)) THEN
  YDGRID%NPARAMID(:)=KPARAMID(:)
ELSE
  YDGRID%NPARAMID(:)=YDGRID%NGRIB(:)
ENDIF
YDGRID%NGRIB3 => YDGRID%NGRIB(1:KG3D)
YDGRID%NGRIB2 => YDGRID%NGRIB(KG3D+1:KG3D+KG2D)
YDGRID%NPARAMID3 => YDGRID%NPARAMID(1:KG3D)
YDGRID%NPARAMID2 => YDGRID%NPARAMID(KG3D+1:KG3D+KG2D)

ALLOCATE(YDGRID%GP3D(YDGRID%NPROMA,YDGRID%NFLEVG,YDGRID%NG3D,YDGRID%NGPBLKS))
ALLOCATE(YDGRID%GP2D(YDGRID%NPROMA,YDGRID%NG2D,YDGRID%NGPBLKS))

NULLIFY(YDGRID%DIV)
NULLIFY(YDGRID%VOR)
NULLIFY(YDGRID%U)
NULLIFY(YDGRID%V)
NULLIFY(YDGRID%T)
NULLIFY(YDGRID%Q)
NULLIFY(YDGRID%O3)
INDD=INDXFIND(YDGRID%NGRIB3,NGRBD)
INDV=INDXFIND(YDGRID%NGRIB3,NGRBVO)
INDU=INDXFIND(YDGRID%NGRIB3,NGRBU)
INDW=INDXFIND(YDGRID%NGRIB3,NGRBV)
INDT=INDXFIND(YDGRID%NGRIB3,NGRBT)
INDQ=INDXFIND(YDGRID%NGRIB3,NGRBQ)
INDO=INDXFIND(YDGRID%NGRIB3,NGRBO3)
IF (INDD>0) YDGRID%DIV => YDGRID%GP3D(:,:,INDD,:)
IF (INDV>0) YDGRID%VOR => YDGRID%GP3D(:,:,INDV,:)
IF (INDU>0) YDGRID%U   => YDGRID%GP3D(:,:,INDU,:)
IF (INDW>0) YDGRID%V   => YDGRID%GP3D(:,:,INDW,:)
IF (INDT>0) YDGRID%T   => YDGRID%GP3D(:,:,INDT,:)
IF (INDQ>0) YDGRID%Q   => YDGRID%GP3D(:,:,INDQ,:)
IF (INDO>0) YDGRID%O3  => YDGRID%GP3D(:,:,INDO,:)

NULLIFY(YDGRID%SPR)
INDS=INDXFIND(YDGRID%NGRIB2,NGRBLNSP)
IF (INDS>0) YDGRID%SPR => YDGRID%GP2D(:,INDS,:)

NULLIFY(YDGRID%WIND)
NULLIFY(YDGRID%SCAL)
IWIND=0
IF (INDD>0) IWIND=IWIND+1
IF (INDV>0) IWIND=IWIND+1
IF (INDU>0) IWIND=IWIND+1
IF (INDW>0) IWIND=IWIND+1
IF (INDD>IWIND.OR.INDV>IWIND.OR.INDU>IWIND.OR.INDW>IWIND) &
  & CALL ABOR1('GRIDPOINT_FIELDS_MIX:ALLOCATE_GRID Error wind')
IF (IWIND>0) YDGRID%WIND => YDGRID%GP3D(:,:,1:IWIND,:)
IF(ASSOCIATED(YDGRID%GP3D)) YDGRID%SCAL => YDGRID%GP3D(:,:,IWIND+1:YDGRID%NG3D,:)

CALL HUGIFY_ENDGRID(YDGRID)

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:ALLOCATE_GRID',1,ZHOOK_HANDLE)
END SUBROUTINE ALLOCATE_GRID

! ------------------------------------------------------------------

SUBROUTINE DEALLOCATE_GRID(YDGRID)

USE DEALLOCATE_IF_ASSOCIATED_MOD, ONLY : DEALLOCATE_IF_ASSOCIATED
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDGRID
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:DEALLOCATE_GRID',0,ZHOOK_HANDLE)

NULLIFY(YDGRID%DIV)
NULLIFY(YDGRID%VOR)
NULLIFY(YDGRID%U)
NULLIFY(YDGRID%V)
NULLIFY(YDGRID%T)
NULLIFY(YDGRID%NGRIB2)
NULLIFY(YDGRID%NGRIB3)
NULLIFY(YDGRID%NPARAMID2)
NULLIFY(YDGRID%NPARAMID3)
CALL DEALLOCATE_IF_ASSOCIATED(YDGRID%NGRIB)
CALL DEALLOCATE_IF_ASSOCIATED(YDGRID%NPARAMID)
CALL DEALLOCATE_IF_ASSOCIATED(YDGRID%GP3D )
CALL DEALLOCATE_IF_ASSOCIATED(YDGRID%GP2D )

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:DEALLOCATE_GRID',1,ZHOOK_HANDLE)
END SUBROUTINE DEALLOCATE_GRID

! ------------------------------------------------------------------

SUBROUTINE ASSIGN_SCALAR_GP(YDGRID,PSCALAR)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDGRID
REAL(KIND=JPRB), INTENT(IN) :: PSCALAR
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:ASSIGN_SCALAR_GP',0,ZHOOK_HANDLE)

YDGRID%GP3D(:,:,:,:)=PSCALAR
YDGRID%GP2D(:,:,:)  =PSCALAR
CALL HUGIFY_ENDGRID(YDGRID)

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:ASSIGN_SCALAR_GP',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_SCALAR_GP

! ------------------------------------------------------------------

SUBROUTINE ASSIGN_GP_GP(YDGRID1,YDGRID2)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDGRID1
TYPE (GRIDPOINT_FIELD), INTENT(IN)    :: YDGRID2
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:ASSIGN_GP_GP',0,ZHOOK_HANDLE)
IF (YDGRID1.NEQV.YDGRID2) CALL ABOR1('Incompatible grid point fields')

YDGRID1%GP3D(:,:,:,:)=YDGRID2%GP3D(:,:,:,:)
YDGRID1%GP2D(:,:,:)  =YDGRID2%GP2D(:,:,:)
CALL HUGIFY_ENDGRID(YDGRID1)

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:ASSIGN_GP_GP',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_GP_GP

! ------------------------------------------------------------------

LOGICAL FUNCTION EQUIV_GRID(YDGRID1,YDGRID2)
TYPE(GRIDPOINT_FIELD), INTENT(IN) :: YDGRID1
TYPE(GRIDPOINT_FIELD), INTENT(IN) :: YDGRID2
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

LOGICAL :: LL
INTEGER(KIND=JPIM) :: JF

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:EQUIV_GRID',0,ZHOOK_HANDLE)

LL = .TRUE.
LL = LL .AND. (YDGRID1%NG2D==YDGRID2%NG2D)
LL = LL .AND. (YDGRID1%NG3D==YDGRID2%NG3D)
IF (LL) THEN
  DO JF=1,YDGRID1%NG2D+YDGRID1%NG3D
    LL = LL .AND. (YDGRID1%NGRIB(JF)==YDGRID2%NGRIB(JF))
  ENDDO
ENDIF

EQUIV_GRID = LL

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:EQUIV_GRID',1,ZHOOK_HANDLE)
END FUNCTION EQUIV_GRID

! ------------------------------------------------------------------

LOGICAL FUNCTION NEQUIV_GRID(YDGRID1,YDGRID2)
TYPE(GRIDPOINT_FIELD), INTENT(IN) :: YDGRID1
TYPE(GRIDPOINT_FIELD), INTENT(IN) :: YDGRID2
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:NEQUIV_GRID',0,ZHOOK_HANDLE)

NEQUIV_GRID = .NOT. EQUIV_GRID(YDGRID1,YDGRID2)

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:NEQUIV_GRID',1,ZHOOK_HANDLE)
END FUNCTION NEQUIV_GRID

! ------------------------------------------------------------------

SUBROUTINE HUGIFY_ENDGRID(YDGRID)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDGRID
REAL(KIND=JPRB) :: ZZZ
INTEGER(KIND=JPIM) :: ILAST, JF, JB, JL, JJ
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:HUGIFY_ENDGRID',0,ZHOOK_HANDLE)

ILAST=YDGRID%NGPTOT-(YDGRID%NGPBLKS-1)*YDGRID%NPROMA
JB=YDGRID%NGPBLKS
ZZZ=HUGE(ZZZ)

DO JF=1,YDGRID%NG3D
  DO JL=1,YDGRID%NFLEVG
    DO JJ=ILAST+1,YDGRID%NPROMA
      YDGRID%GP3D(JJ,JL,JF,JB)=ZZZ
    ENDDO
  ENDDO
ENDDO
DO JF=1,YDGRID%NG2D
  DO JJ=ILAST+1,YDGRID%NPROMA
    YDGRID%GP2D(JJ,JF,JB)=ZZZ
  ENDDO
ENDDO

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:HUGIFY_ENDGRID',1,ZHOOK_HANDLE)
END SUBROUTINE HUGIFY_ENDGRID

! ------------------------------------------------------------------

SUBROUTINE SELF_ADD_GP(YDA,YDB)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDA
TYPE (GRIDPOINT_FIELD), INTENT(IN)    :: YDB
INTEGER(KIND=JPIM) :: JB,JF,JL,JJ,ILEN
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_ADD_GP',0,ZHOOK_HANDLE)

IF (YDA.NEQV.YDB) CALL ABOR1('SELF_ADD_GP: Incompatible gridpoint fields')
IF (YDA%NGPTOTG/=YDB%NGPTOTG .OR. YDA%NGPTOT/=YDB%NGPTOT) &
  & CALL ABOR1('SELF_ADD_GP: Incompatible gridpoint resolutions')

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jb,ilen,jf,jl,jj)
DO JB=1,YDA%NGPBLKS
  ILEN=MIN(YDA%NPROMA, YDA%NGPTOT-(JB-1)*YDA%NPROMA)
  DO JF=1,YDA%NG3D
    DO JL=1,YDA%NFLEVG
      DO JJ=1,ILEN
        YDA%GP3D(JJ,JL,JF,JB) = YDA%GP3D(JJ,JL,JF,JB) + YDB%GP3D(JJ,JL,JF,JB)
      ENDDO
    ENDDO
  ENDDO
  DO JF=1,YDA%NG2D
    DO JJ=1,ILEN
      YDA%GP2D(JJ,JF,JB) = YDA%GP2D(JJ,JF,JB) + YDB%GP2D(JJ,JF,JB)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_ADD_GP',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_ADD_GP
! ------------------------------------------------------------------

SUBROUTINE SELF_ADD_SCAL(YDA,PB)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDA
REAL(KIND=JPRB), INTENT(IN) :: PB
INTEGER(KIND=JPIM) :: JB,JF,JL,JJ,ILEN
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_ADD_SCAL',0,ZHOOK_HANDLE)

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jb,ilen,jf,jl,jj)
DO JB=1,YDA%NGPBLKS
  ILEN=MIN(YDA%NPROMA, YDA%NGPTOT-(JB-1)*YDA%NPROMA)
  DO JF=1,YDA%NG3D
    DO JL=1,YDA%NFLEVG
      DO JJ=1,ILEN
        YDA%GP3D(JJ,JL,JF,JB) = PB + YDA%GP3D(JJ,JL,JF,JB)
      ENDDO
    ENDDO
  ENDDO
  DO JF=1,YDA%NG2D
    DO JJ=1,ILEN
      YDA%GP2D(JJ,JF,JB) = PB + YDA%GP2D(JJ,JF,JB)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_ADD_SCAL',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_ADD_SCAL
! ------------------------------------------------------------------

REAL(KIND=JPRB) FUNCTION DOT_PRODUCT_GP(YDA,YDB)
USE ORDER_INDEPENDENT_SUMMATION_MOD, ONLY : ORDER_INDEP_GLOBAL_SUM
IMPLICIT NONE
TYPE (GRIDPOINT_FIELD), INTENT(IN) :: YDA
TYPE (GRIDPOINT_FIELD), INTENT(IN) :: YDB

INTEGER(KIND=JPIM) :: JB,JF,JL,JJ,ILEN
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
REAL(KIND=JPRB) :: ZZ(1)

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:DOT_PRODUCT_GP',0,ZHOOK_HANDLE)
IF (YDA.NEQV.YDB) CALL ABOR1('DOT_PRODUCT_GP: Incompatible gridpoint fields')
IF (YDA%NGPTOTG/=YDB%NGPTOTG .OR. YDA%NGPTOT/=YDB%NGPTOT) &
  & CALL ABOR1('DOT_PRODUCT_GP: Incompatible gridpoint resolutions')
DOT_PRODUCT_GP=0.0_JPRB
ZZ=0.0_JPRB

DO JB=1,YDA%NGPBLKS
  ILEN=MIN(YDA%NPROMA, YDA%NGPTOT-(JB-1)*YDA%NPROMA)
  DO JF=1,YDA%NG3D
    DO JL=1,YDA%NFLEVG
      ZZ(1) = ZZ(1) + DOT_PRODUCT(YDA%GP3D(1:ILEN,JL,JF,JB),YDB%GP3D(1:ILEN,JL,JF,JB))
    ENDDO
  ENDDO
  DO JF=1,YDA%NG2D
    ZZ(1) = ZZ(1) + DOT_PRODUCT(YDA%GP2D(1:ILEN,JF,JB),YDB%GP2D(1:ILEN,JF,JB))
  ENDDO
ENDDO
DOT_PRODUCT_GP = ORDER_INDEP_GLOBAL_SUM(ZZ,KNG=1)

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:DOT_PRODUCT_GP',1,ZHOOK_HANDLE)
END FUNCTION DOT_PRODUCT_GP
! ------------------------------------------------------------------

SUBROUTINE SELF_AXPY_GP(YDA,YDB,PZ)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDA
TYPE (GRIDPOINT_FIELD), INTENT(IN)    :: YDB
REAL(KIND=JPRB),        INTENT(IN)    :: PZ
INTEGER(KIND=JPIM) :: JB,JF,JL,JJ,ILEN
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_AXPY_GP',0,ZHOOK_HANDLE)

IF (YDA.NEQV.YDB) CALL ABOR1('SELF_AXPY_GP: Incompatible gridpoint fields')
IF (YDA%NGPTOTG/=YDB%NGPTOTG .OR. YDA%NGPTOT/=YDB%NGPTOT) &
  & CALL ABOR1('SELF_AXPY_GP: Incompatible gridpoint resolutions')

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jb,ilen,jf,jl,jj)
DO JB=1,YDA%NGPBLKS
  ILEN=MIN(YDA%NPROMA, YDA%NGPTOT-(JB-1)*YDA%NPROMA)
  DO JF=1,YDA%NG3D
    DO JL=1,YDA%NFLEVG
      DO JJ=1,ILEN
        YDA%GP3D(JJ,JL,JF,JB) = YDA%GP3D(JJ,JL,JF,JB) + PZ*YDB%GP3D(JJ,JL,JF,JB)
      ENDDO
    ENDDO
  ENDDO
  DO JF=1,YDA%NG2D
    DO JJ=1,ILEN
      YDA%GP2D(JJ,JF,JB) = YDA%GP2D(JJ,JF,JB) + PZ*YDB%GP2D(JJ,JF,JB)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_AXPY_GP',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_AXPY_GP
! ------------------------------------------------------------------

SUBROUTINE SELF_SUB_GP(YDA,YDB)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDA
TYPE (GRIDPOINT_FIELD), INTENT(IN)    :: YDB
INTEGER(KIND=JPIM) :: JB,JF,JL,JJ,ILEN
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_SUB_GP',0,ZHOOK_HANDLE)

IF (YDA.NEQV.YDB) CALL ABOR1('SELF_SUB_GP: Incompatible gridpoint fields')
IF (YDA%NGPTOTG/=YDB%NGPTOTG .OR. YDA%NGPTOT/=YDB%NGPTOT) &
  & CALL ABOR1('SELF_SUB_GP: Incompatible gridpoint resolutions')

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jb,ilen,jf,jl,jj)
DO JB=1,YDA%NGPBLKS
  ILEN=MIN(YDA%NPROMA, YDA%NGPTOT-(JB-1)*YDA%NPROMA)
  DO JF=1,YDA%NG3D
    DO JL=1,YDA%NFLEVG
      DO JJ=1,ILEN
        YDA%GP3D(JJ,JL,JF,JB) = YDA%GP3D(JJ,JL,JF,JB) - YDB%GP3D(JJ,JL,JF,JB)
      ENDDO
    ENDDO
  ENDDO
  DO JF=1,YDA%NG2D
    DO JJ=1,ILEN
      YDA%GP2D(JJ,JF,JB) = YDA%GP2D(JJ,JF,JB) - YDB%GP2D(JJ,JF,JB)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_SUB_GP',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_SUB_GP
! ------------------------------------------------------------------

SUBROUTINE SELF_MUL_GP(YDA,YDB)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDA
TYPE (GRIDPOINT_FIELD), INTENT(IN)    :: YDB
INTEGER(KIND=JPIM) :: JB,JF,JL,JJ,ILEN
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_MUL_GP',0,ZHOOK_HANDLE)

IF (YDA.NEQV.YDB) CALL ABOR1('SELF_MUL_GP: Incompatible gridpoint fields')
IF (YDA%NGPTOTG/=YDB%NGPTOTG .OR. YDA%NGPTOT/=YDB%NGPTOT) &
  & CALL ABOR1('SELF_MUL_GP: Incompatible gridpoint resolutions')

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jb,ilen,jf,jl,jj)
DO JB=1,YDA%NGPBLKS
  ILEN=MIN(YDA%NPROMA, YDA%NGPTOT-(JB-1)*YDA%NPROMA)
  DO JF=1,YDA%NG3D
    DO JL=1,YDA%NFLEVG
      DO JJ=1,ILEN
        YDA%GP3D(JJ,JL,JF,JB) = YDA%GP3D(JJ,JL,JF,JB) * YDB%GP3D(JJ,JL,JF,JB)
      ENDDO
    ENDDO
  ENDDO
  DO JF=1,YDA%NG2D
    DO JJ=1,ILEN
      YDA%GP2D(JJ,JF,JB) = YDA%GP2D(JJ,JF,JB) * YDB%GP2D(JJ,JF,JB)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_MUL_GP',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_MUL_GP

! ------------------------------------------------------------------

SUBROUTINE SELF_MUL_SCAL(YDA,PB)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDA
REAL(KIND=JPRB), INTENT(IN) :: PB
INTEGER(KIND=JPIM) :: JB,JF,JL,JJ,ILEN
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_MUL_SCAL',0,ZHOOK_HANDLE)

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jb,ilen,jf,jl,jj)
DO JB=1,YDA%NGPBLKS
  ILEN=MIN(YDA%NPROMA, YDA%NGPTOT-(JB-1)*YDA%NPROMA)
  DO JF=1,YDA%NG3D
    DO JL=1,YDA%NFLEVG
      DO JJ=1,ILEN
        YDA%GP3D(JJ,JL,JF,JB) = PB * YDA%GP3D(JJ,JL,JF,JB)
      ENDDO
    ENDDO
  ENDDO
  DO JF=1,YDA%NG2D
    DO JJ=1,ILEN
      YDA%GP2D(JJ,JF,JB) = PB * YDA%GP2D(JJ,JF,JB)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:SELF_MUL_SCAL',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_MUL_SCAL
! ------------------------------------------------------------------

SUBROUTINE CLIP_GRID(YDA, PMIN2D, PMAX2D, PMIN3D, PMAX3D)
TYPE (GRIDPOINT_FIELD), INTENT(INOUT) :: YDA
REAL(KIND=JPRB), INTENT(IN), DIMENSION(YDA%NG2D)             ,OPTIONAL :: PMIN2D
REAL(KIND=JPRB), INTENT(IN), DIMENSION(YDA%NG2D)             ,OPTIONAL :: PMAX2D
REAL(KIND=JPRB), INTENT(IN), DIMENSION(YDA%NFLEVG, YDA%NG3D) ,OPTIONAL :: PMIN3D
REAL(KIND=JPRB), INTENT(IN), DIMENSION(YDA%NFLEVG, YDA%NG3D) ,OPTIONAL :: PMAX3D
INTEGER(KIND=JPIM) :: JB,JF,JL,JJ,ILEN

LOGICAL :: LLMIN2D, LLMAX2D, LLMIN3D, LLMAX3D

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:CLIP_GRID',0,ZHOOK_HANDLE)

LLMIN2D=PRESENT(PMIN2D)
LLMAX2D=PRESENT(PMAX2D)
LLMIN3D=PRESENT(PMIN3D)
LLMAX3D=PRESENT(PMAX3D)


!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jb,ilen,jf,jl,jj)
DO JB=1,YDA%NGPBLKS
  ILEN=MIN(YDA%NPROMA, YDA%NGPTOT-(JB-1)*YDA%NPROMA)
  IF (LLMIN3D.OR.LLMAX3D) THEN
    DO JF=1,YDA%NG3D
      DO JL=1,YDA%NFLEVG
        DO JJ=1,ILEN
          IF (LLMAX3D) THEN
            YDA%GP3D(JJ,JL,JF,JB) = MIN(PMAX3D(JL,JF),YDA%GP3D(JJ,JL,JF,JB))
          ENDIF
          IF (LLMIN3D) THEN
            YDA%GP3D(JJ,JL,JF,JB) = MAX(PMIN3D(JL,JF),YDA%GP3D(JJ,JL,JF,JB))
          ENDIF
        ENDDO
      ENDDO
    ENDDO
  ENDIF
  IF (LLMIN2D.OR.LLMAX2D) THEN
    DO JF=1,YDA%NG2D
      DO JJ=1,ILEN
        IF (LLMAX2D) THEN
          YDA%GP2D(JJ,JF,JB) = MIN( PMAX2D(JF), YDA%GP2D(JJ,JF,JB) )
        ENDIF
        IF (LLMIN2D) THEN
          YDA%GP2D(JJ,JF,JB) = MAX( PMIN2D(JF), YDA%GP2D(JJ,JF,JB) )
        ENDIF
      ENDDO
    ENDDO
  ENDIF
ENDDO
!yt!$OMP END PARALLEL DO

IF (LHOOK) CALL DR_HOOK('GRIDPOINT_FIELDS_MIX:CLIP_GRID',1,ZHOOK_HANDLE)
END SUBROUTINE CLIP_GRID
! ------------------------------------------------------------------

END MODULE GRIDPOINT_FIELDS_MIX
