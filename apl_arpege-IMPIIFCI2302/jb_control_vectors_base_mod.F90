MODULE JB_CONTROL_VECTORS_BASE_MOD

!   Purpose.
!   --------
!     This module contains the definition of the JB_CONTROL_VECTOR type
!     and basic routines (allocate, deallocate).
!
!   Author.
!   -------
!     M. Fisher
!
!   Modifications.
!   --------------
!     Original   09-Aug-2012 Split from CONTROL_VECTORS_BASE_MIX
!     Y. Michel, MF, June 2018 Extention of the control variable for sqrt EnVar
! ------------------------------------------------------------------

USE PARKIND1,     ONLY : JPIM, JPRB
USE YOMLUN,       ONLY : NULERR
USE YOMMP0  ,     ONLY : NPROC
USE YOMHOOK ,     ONLY : LHOOK, DR_HOOK, JPHOOK
USE GEOMETRY_MOD, ONLY : GEOMETRY
USE SPECTRAL_FIELDS_MOD, ONLY: SPECTRAL_FIELD, INQ_SPEC, DEALLOCATE_SPEC
USE CONTROL_VECTORS_DATA_MIX, ONLY:  CONTROL_VECTOR_DATA_STRUCT

IMPLICIT NONE
PRIVATE
PUBLIC JB_CONTROL_VECTOR, JB_CONTROL_VECTOR_CONTAINER, &
     & ALLOCATE_JB_CTLVEC, DEALLOCATE_JB_CTLVEC,&
     & ALLOCATE_JB_CTLVEC_NODATA, DEALLOCATE_JB_CTLVEC_NODATA,&
     & OPERATOR (.EQV.), OPERATOR (.NEQV.), CHECK

! ------------------------------------------------------------------

TYPE JB_CONTROL_VECTOR
  LOGICAL :: LALLOC = .FALSE.
  LOGICAL :: LWAVELETJB
  LOGICAL :: LELAM
  LOGICAL :: LENS=.FALSE.
  INTEGER(KIND=JPIM) :: NSMAX, NMSMAX
  INTEGER(KIND=JPIM) :: NS3D, NS2D, NS1D
  INTEGER(KIND=JPIM) :: NSIZEL, NSIZEG, NSCALES
  INTEGER(KIND=JPIM), POINTER :: IBGN_SCALE(:) => NULL()
  REAL(KIND=JPRB), POINTER :: DATA(:) => NULL()
  TYPE(CONTROL_VECTOR_DATA_STRUCT), POINTER :: STRUCT => NULL()
  TYPE(GEOMETRY), POINTER :: GEOM => NULL()
END TYPE JB_CONTROL_VECTOR

! ------------------------------------------------------------------

TYPE :: JB_CONTROL_VECTOR_CONTAINER
  CLASS(JB_CONTROL_VECTOR), POINTER :: OBJ
END TYPE JB_CONTROL_VECTOR_CONTAINER

! ------------------------------------------------------------------

INTERFACE ALLOCATE_JB_CTLVEC
MODULE PROCEDURE ALLOCATE_JBCV, ALLOCATE_JBCV_JBCV
END INTERFACE

INTERFACE CHECK
MODULE PROCEDURE CHECK_JBCV, CHECK_JBCV_JBCV
END INTERFACE

INTERFACE OPERATOR (.EQV.)
MODULE PROCEDURE EQUIV_JBCV
END INTERFACE

INTERFACE OPERATOR (.NEQV.)
MODULE PROCEDURE NEQUIV_JBCV
END INTERFACE

! ------------------------------------------------------------------
CONTAINS
! ------------------------------------------------------------------

SUBROUTINE ALLOCATE_JB_CTLVEC_NODATA(YDCV,KSMAX,KMSMAX,KS3D,KS2D,KS1D,KNSCALES,LLENS)
! ------------------------------------------------------------------
! Setup Jb control vector, but leave ydcv%data unallocated.
! This routine should only be called from ALLOCATE_CONTROL_VECTOR or
! ALLOCATE_JB_CONTROL_VECTOR.
! ------------------------------------------------------------------

USE CONTROL_VECTORS_DATA_MIX, ONLY : CTLVEC_STRUCT, CTLVEC_STRUCT_ENS

TYPE(JB_CONTROL_VECTOR), INTENT(INOUT)   :: YDCV
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: KSMAX,KMSMAX
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: KS3D,KS2D,KS1D,KNSCALES
LOGICAL, OPTIONAL, INTENT(IN) :: LLENS

INTEGER(KIND=JPIM) :: IEND_IC,IBGN,ILEN,JJ
TYPE(SPECTRAL_FIELD) :: YLSP

! Default values
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:ALLOCATE_JB_CTLVEC_NODATA',0,ZHOOK_HANDLE)

IF (.NOT.ASSOCIATED(CTLVEC_STRUCT)) THEN
  CALL ABOR1('Trying to allocate a jb_control_vector, but CTLVEC_STRUCT is not initialised')
ENDIF

YDCV%STRUCT => CTLVEC_STRUCT
IF (PRESENT(LLENS)) THEN
   IF (LLENS) THEN
      IF (.NOT.ASSOCIATED(CTLVEC_STRUCT_ENS)) THEN
         CALL ABOR1('Trying to allocate a jb_control_vector, but CTLVEC_STRUCT_ENS is not initialised')
      ENDIF
      YDCV%STRUCT => CTLVEC_STRUCT_ENS
   ENDIF
   YDCV%LENS=LLENS
ENDIF
YDCV%NSMAX     = YDCV%STRUCT%NSMAX
YDCV%NMSMAX    = YDCV%STRUCT%NMSMAX
YDCV%NS3D      = YDCV%STRUCT%NCTL3
YDCV%NS2D      = YDCV%STRUCT%NCTL2
YDCV%NS1D      = YDCV%STRUCT%NCTL1
YDCV%LWAVELETJB= YDCV%STRUCT%LWAVELETJB
YDCV%LELAM     = YDCV%STRUCT%LELAM
IF (YDCV%STRUCT%LWAVELETJB) THEN
  YDCV%NSCALES = YDCV%STRUCT%NSCALES
ENDIF

! Check for optional arguments
IF (PRESENT(KSMAX))    YDCV%NSMAX   = KSMAX
IF (PRESENT(KMSMAX))   YDCV%NMSMAX  = KMSMAX
IF (PRESENT(KS3D))     YDCV%NS3D    = KS3D
IF (PRESENT(KS2D))     YDCV%NS2D    = KS2D
IF (PRESENT(KS1D))     YDCV%NS1D    = KS1D
IF (PRESENT(KNSCALES)) YDCV%NSCALES = KNSCALES

IF (PRESENT(KNSCALES).AND.YDCV%STRUCT%LWAVELETJB) THEN
  IF (KNSCALES >YDCV%STRUCT%NSCALES) THEN
    WRITE(*,*) 'knscales too large: knscales=',KNSCALES,' > NSCALES=',YDCV%STRUCT%NSCALES
    CALL ABOR1('knscales>NSCALES in allocate_jbcv')
  ENDIF
ENDIF

YDCV%NSIZEL=0
YDCV%NSIZEG=0

IF (.NOT.YDCV%LWAVELETJB) THEN

  CALL INQ_SPEC(YLSP,YDCV%STRUCT%NFLEVL,YDCV%STRUCT%NFLEVG,&
        & YDCV%STRUCT%NUMP,YDCV%STRUCT%MYMS,YDCV%NSMAX,YDCV%NMSMAX,&
        & YDCV%STRUCT%NALLMS,YDCV%STRUCT%NPTRMS,YDCV%STRUCT%NUMLL,&
        & YDCV%STRUCT%NPTRLL,YDCV%STRUCT%NPSURF,YDCV%NS3D,YDCV%NS2D)

  ILEN=YLSP%NSPSIZEL
  IEND_IC=ILEN
  YDCV%NSIZEL=ILEN
  ILEN=YLSP%NSPSIZEG
  YDCV%NSIZEG=ILEN
  CALL DEALLOCATE_SPEC(YLSP)
ELSEIF (.NOT. YDCV%LELAM) THEN
  IF (YDCV%NSCALES==YDCV%STRUCT%NSCALES) THEN
    ILEN=YDCV%STRUCT%NPROMA*(YDCV%STRUCT%NFLEVG*YDCV%NS3D+YDCV%NS2D)*SUM(YDCV%STRUCT%NBLOCKSL(:))
  ELSE
    ILEN = YDCV%STRUCT%NPROMA*(YDCV%STRUCT%NFLEVG*YDCV%NS3D+YDCV%NS2D)&
        & *(2*YDCV%STRUCT%NBLOCKSL(2+YDCV%STRUCT%NSCALES-YDCV%NSCALES)&
        &   +SUM(YDCV%STRUCT%NBLOCKSL(3+YDCV%STRUCT%NSCALES-YDCV%NSCALES:)) )
  ENDIF
  IEND_IC=ILEN
  YDCV%NSIZEL=ILEN
  IF (NPROC > 1) THEN
    IF (YDCV%NSCALES==YDCV%STRUCT%NSCALES) THEN
      YDCV%NSIZEG=(YDCV%STRUCT%NFLEVG*YDCV%NS3D+YDCV%NS2D)*SUM(YDCV%STRUCT%NGPTOTG(:))
    ELSE
      YDCV%NSIZEG = (YDCV%STRUCT%NFLEVG*YDCV%NS3D+YDCV%NS2D)&
               & *(2*YDCV%STRUCT%NGPTOTG(2+YDCV%STRUCT%NSCALES-YDCV%NSCALES)&
               &   +SUM(YDCV%STRUCT%NGPTOTG(3+YDCV%STRUCT%NSCALES-YDCV%NSCALES:)) )
    ENDIF
  ELSE
    YDCV%NSIZEG = YDCV%NSIZEL
  ENDIF

  ALLOCATE(YDCV%IBGN_SCALE(YDCV%NSCALES))
  IBGN=1
  DO JJ=1,YDCV%NSCALES
    YDCV%IBGN_SCALE(JJ) = IBGN
    IF (YDCV%NSCALES==YDCV%STRUCT%NSCALES) THEN
      ILEN = YDCV%STRUCT%NPROMA*(YDCV%STRUCT%NFLEVG*YDCV%NS3D+YDCV%NS2D)*YDCV%STRUCT%NBLOCKSL(JJ)
    ELSE
      ILEN = YDCV%STRUCT%NPROMA*(YDCV%STRUCT%NFLEVG*YDCV%NS3D+YDCV%NS2D)&
                 & *YDCV%STRUCT%NBLOCKSL(MAX(2,JJ)+YDCV%STRUCT%NSCALES-YDCV%NSCALES)
    ENDIF
    IBGN = IBGN + ILEN
  ENDDO
  IF (IBGN /= 1+IEND_IC) CALL ABOR1 ('Error defining indices for initcv')
ELSE ! LAM wavelets
  ILEN = 4*(YDCV%STRUCT%NCTL3*YDCV%STRUCT%NFLEVG+YDCV%STRUCT%NCTL2)*YDCV%STRUCT%NBLOCKSL(1)*YDCV%STRUCT%NBLOCKSL(2)
  IEND_IC=ILEN
  YDCV%NSIZEL=ILEN
  YDCV%NSIZEG = 4*(YDCV%STRUCT%NCTL3*YDCV%STRUCT%NFLEVG+YDCV%STRUCT%NCTL2)&
              &  *YDCV%STRUCT%NBLOCKSG(1)*YDCV%STRUCT%NBLOCKSG(2)
ENDIF

IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:ALLOCATE_JB_CTLVEC_NODATA',1,ZHOOK_HANDLE)
END SUBROUTINE ALLOCATE_JB_CTLVEC_NODATA
! ------------------------------------------------------------------

SUBROUTINE ALLOCATE_JBCV(YDCV,KSMAX,KMSMAX,KS3D,KS2D,KS1D,KNSCALES,LLENS)

TYPE(JB_CONTROL_VECTOR), INTENT(INOUT)   :: YDCV
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: KSMAX,KMSMAX
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: KS3D,KS2D,KS1D,KNSCALES
LOGICAL, OPTIONAL, INTENT(IN) :: LLENS

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:ALLOCATE_JBCV',0,ZHOOK_HANDLE)

CALL ALLOCATE_JB_CTLVEC_NODATA(YDCV,KSMAX,KMSMAX,KS3D,KS2D,KS1D,KNSCALES,LLENS)

ALLOCATE(YDCV%DATA(1:YDCV%NSIZEL))
YDCV%LALLOC = .TRUE.

IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:ALLOCATE_JBCV',1,ZHOOK_HANDLE)
END SUBROUTINE ALLOCATE_JBCV

! ------------------------------------------------------------------

SUBROUTINE ALLOCATE_JBCV_JBCV(YDCV,YDIN)
TYPE(JB_CONTROL_VECTOR), INTENT(INOUT) :: YDCV
TYPE(JB_CONTROL_VECTOR), INTENT(IN)    :: YDIN

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:ALLOCATE_JBCV_JBCV',0,ZHOOK_HANDLE)

CALL ALLOCATE_JBCV(YDCV, KSMAX=YDIN%NSMAX, KMSMAX=YDIN%NMSMAX,&
               & KS3D=YDIN%NS3D, KS2D=YDIN%NS2D, KS1D=YDIN%NS1D,&
               & KNSCALES=YDIN%NSCALES,LLENS=YDIN%LENS)

IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:ALLOCATE_JBCV_JBCV',1,ZHOOK_HANDLE)
END SUBROUTINE ALLOCATE_JBCV_JBCV

! ------------------------------------------------------------------

SUBROUTINE DEALLOCATE_JB_CTLVEC_NODATA(YDCV)
! ------------------------------------------------------------------
! Deallocate Jb control vector, but leave ydcv%data for
! DEALLOCATE_CONTROL_VECTOR to deal with,
! This routine should only be called from DEALLOCATE_CONTROL_VECTOR.
! ------------------------------------------------------------------
TYPE(JB_CONTROL_VECTOR), INTENT(INOUT) :: YDCV

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:DEALLOCATE_JB_CTLVEC_NODATA',0,ZHOOK_HANDLE)

IF (YDCV%LALLOC) THEN
  IF (ASSOCIATED(YDCV%IBGN_SCALE)) DEALLOCATE(YDCV%IBGN_SCALE)
  YDCV%LALLOC = .FALSE.
ELSE
  WRITE(NULERR,*)'Warning: trying to deallocate unallocated NODATA JB_CONTROL_VECTOR'
ENDIF

IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:DEALLOCATE_JB_CTLVEC_NODATA',1,ZHOOK_HANDLE)
END SUBROUTINE DEALLOCATE_JB_CTLVEC_NODATA

! ------------------------------------------------------------------

SUBROUTINE DEALLOCATE_JB_CTLVEC(YDCV)
TYPE(JB_CONTROL_VECTOR), INTENT(INOUT) :: YDCV

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:DEALLOCATE_JB_CTLVEC',0,ZHOOK_HANDLE)

IF (YDCV%LALLOC) THEN
  IF (ASSOCIATED(YDCV%DATA)) DEALLOCATE(YDCV%DATA)
  IF (ASSOCIATED(YDCV%IBGN_SCALE)) DEALLOCATE(YDCV%IBGN_SCALE)
  YDCV%LALLOC = .FALSE.
ELSE
  WRITE(NULERR,*)'Warning: trying to deallocate unallocated JB_CONTROL_VECTOR'
ENDIF

NULLIFY(YDCV%STRUCT)

IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:DEALLOCATE_JB_CTLVEC',1,ZHOOK_HANDLE)
END SUBROUTINE DEALLOCATE_JB_CTLVEC

! ------------------------------------------------------------------

SUBROUTINE CHECK_JBCV(YDCV)
TYPE(JB_CONTROL_VECTOR), INTENT(IN) :: YDCV

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:CHECK_JBCV',0,ZHOOK_HANDLE)
IF (.NOT.(YDCV%LALLOC)) THEN
  CALL ABOR1('Jb Control vector not allocated')
ENDIF
!yt the following is temporary, lalloc can be removed after
!yt this has been tested.
IF (ASSOCIATED(YDCV%DATA) .AND. .NOT.(YDCV%LALLOC)) THEN
  CALL ABOR1('Jb Control vector associated but not lalloc')
ENDIF
IF (.NOT.ASSOCIATED(YDCV%DATA) .AND. YDCV%LALLOC) THEN
  CALL ABOR1('Jb Control vector lalloc but not associated')
ENDIF

IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:CHECK_JBCV',1,ZHOOK_HANDLE)
END SUBROUTINE CHECK_JBCV

! ------------------------------------------------------------------

SUBROUTINE CHECK_JBCV_JBCV(YDCV1,YDCV2)
TYPE(JB_CONTROL_VECTOR), INTENT(IN) :: YDCV1, YDCV2

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:CHECK_JBCV_JBCV',0,ZHOOK_HANDLE)
IF (.NOT.(YDCV1%LALLOC .AND. YDCV2%LALLOC)) THEN
  CALL ABOR1('Jb Control vectors not allocated')
ENDIF
IF (YDCV1.NEQV.YDCV2) THEN
  CALL ABOR1('Jb Control vectors are incompatible')
ENDIF

IF ((YDCV1%NSMAX/=YDCV2%NSMAX) .OR.&
 &((YDCV1%NMSMAX/=YDCV2%NMSMAX).AND.(YDCV1%LELAM))) THEN
  CALL ABOR1('Jb Control vectors have different resolution')
ENDIF

IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:CHECK_JBCV_JBCV',1,ZHOOK_HANDLE)
END SUBROUTINE CHECK_JBCV_JBCV

! ------------------------------------------------------------------

LOGICAL FUNCTION EQUIV_JBCV(YDCV1,YDCV2)
TYPE(JB_CONTROL_VECTOR), INTENT(IN) :: YDCV1
TYPE(JB_CONTROL_VECTOR), INTENT(IN) :: YDCV2
LOGICAL :: LL

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:EQUIV_JBCV',0,ZHOOK_HANDLE)
LL = .TRUE.
LL = LL .AND. (YDCV1%NS3D   == YDCV2%NS3D)
LL = LL .AND. (YDCV1%NS2D   == YDCV2%NS2D)
LL = LL .AND. (YDCV1%NS1D   == YDCV2%NS1D)

EQUIV_JBCV=LL
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:EQUIV_JBCV',1,ZHOOK_HANDLE)
END FUNCTION EQUIV_JBCV

! ------------------------------------------------------------------

LOGICAL FUNCTION NEQUIV_JBCV(YDCV1,YDCV2)
TYPE(JB_CONTROL_VECTOR), INTENT(IN) :: YDCV1
TYPE(JB_CONTROL_VECTOR), INTENT(IN) :: YDCV2

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:NEQUIV_JBCV',0,ZHOOK_HANDLE)
NEQUIV_JBCV = .NOT. EQUIV_JBCV(YDCV1,YDCV2)

IF (LHOOK) CALL DR_HOOK('JB_CONTROL_VECTORS_BASE_MOD:NEQUIV_JBCV',1,ZHOOK_HANDLE)
END FUNCTION NEQUIV_JBCV

! ------------------------------------------------------------------

END MODULE JB_CONTROL_VECTORS_BASE_MOD
