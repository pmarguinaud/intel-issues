! radiation_single_level.F90 - Derived type for single-level fields
!
! (C) Copyright 2014- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!
! Author:  Robin Hogan
! Email:   r.j.hogan@ecmwf.int
!
! Modifications
!   2019-01-14  R. Hogan  Added out_of_physical_bounds routine
!   2019-01-18  R. Hogan  Added weighted albedo mapping

module radiation_single_level

  use parkind1

  implicit none
  

  !---------------------------------------------------------------------
  ! Derived type to contain variables that don't vary with height;
  ! mostly they are surface properties
  type single_level_type
    ! Note that skin temperature is only defined if
    ! is_simple_surface==.true.
    real(jprb), allocatable, dimension(:) :: &
         &   cos_sza, &       ! (ncol) Cosine of solar zenith angle
         &   skin_temperature ! (ncol) Skin temperature (K)

    ! Shortwave albedo: if sw_albedo_direct is not allocated then
    ! sw_albedo will be used for both direct and diffuse solar
    ! radiation; otherwise, sw_albedo will be used for diffuse
    ! radiation and sw_albedo_direct for direct radiation.
    real(jprb), allocatable, dimension(:,:) :: &
         &   sw_albedo, &        ! (ncol,nalbedobands)
         &   sw_albedo_direct    ! (ncol,nalbedobands)

    ! If is_simple_surface==.true., we provide longwave emissivity
    ! coarser spectral intervals, while if
    ! is_simple_surface==.false. it will be generated by the surface
    ! radiation scheme and may optionally be on the full spectral grid
    ! of the atmospheric model.
    real(jprb), allocatable, dimension(:,:) :: &
         &   lw_emissivity       ! (ncol,nemissbands) If
    ! is_simple_surface==.false. then we specify the emission instead
    ! of the skin temperature, and again this may be on the emissivity
    ! bands or the full spectral grid
    real(jprb), allocatable, dimension(:,:) :: &
         &   lw_emission         ! (ncol,nemissbands)

    ! Incoming solar irradiance at the Earth is specified as the total
    ! across the shortwave spectrum. Note that this needs to be
    ! adjusted for Earth-Sun distance, solar cycle etc. To get
    ! normalized fluxes out, simply set this to 1.0.
    real(jprb) :: solar_irradiance = 1366.0_jprb ! W m-2

    ! In addition to the effect of the solar cycle on total solar
    ! irradiance (which the user is expected to input via
    ! solar_irradiance), it can change the balance between different
    ! parts of the solar spectrum, e.g. more UV at solar maximum. This
    ! variable provides the scaling to be applied to the spectral
    ! amplitude of the solar cycle (assuming it has been provided),
    ! e.g. 1.0 for solar maximum, -1.0 for solar maximum and 0.0 for
    ! a mean solar spectrum.
    real(jprb) :: spectral_solar_cycle_multiplier = 0.0_jprb

    ! If config%use_spectral_solar_irradiance==true then this will be
    ! scaled by spectral_solar_scaling
    real(jprb), allocatable, dimension(:) :: &
         &   spectral_solar_scaling ! (n_bands_sw)

    ! Seed for random number generator in McICA; it is expected that
    ! the host model generates this from the model time, longitude
    ! and latitude, in order that the model is deterministic
    integer, allocatable, dimension(:) :: iseed ! (ncol)

    ! Is the underlying surface a simple single "flat" tile? If so we
    ! describe it with skin_temperature and lw_emissivity. Otherwise
    ! we describe it with lw_emission and lw_emissivity coming out of
    ! the surface radiation scheme.
    logical :: is_simple_surface = .true.

    ! If is_simple_surface==.false., do we use the full number of g
    ! points for dimensioning sw_albedo, sw_albedo_direct and
    ! lw_emission?
    !logical :: use_full_spectrum_sw = .false.
    !logical :: use_full_spectrum_lw = .true.

  contains
    
    
    
    
    
    
    
    
    

  procedure :: allocate_GPU   => allocate_single_level_GPU

  procedure :: deallocate_GPU => deallocate_single_level_GPU

  procedure :: init_seed_simple_GPU

  procedure :: get_albedos_GPU

  procedure :: out_of_physical_bounds_GPU

  procedure :: create_device_GPU

  procedure :: update_host_GPU

  procedure :: update_device_GPU

  procedure :: delete_device_GPU

  procedure :: allocate_CPU   => allocate_single_level_CPU

  procedure :: deallocate_CPU => deallocate_single_level_CPU

  procedure :: init_seed_simple_CPU

  procedure :: get_albedos_CPU

  procedure :: out_of_physical_bounds_CPU

  end type single_level_type

  private :: create_device_GPU, update_host_GPU, update_device_GPU, delete_device_GPU

contains

  !---------------------------------------------------------------------
  ! Allocate the arrays of a single-level type
  


  !---------------------------------------------------------------------
  ! Deallocate the arrays of a single-level type
  


  !---------------------------------------------------------------------
  ! Unimaginative initialization of random-number seeds
  


  !---------------------------------------------------------------------
  ! Extract the shortwave and longwave surface albedos in each g-point
  


  !---------------------------------------------------------------------
  ! Return .true. if the contents of a single_level structure are out
  ! of a physically sensible range, optionally only considering only
  ! columns between istartcol and iendcol
  

  !---------------------------------------------------------------------
  ! creates fields on device
  

  !---------------------------------------------------------------------
  ! updates fields on host
  

  !---------------------------------------------------------------------
  ! updates fields on device
  

  !---------------------------------------------------------------------
  ! deletes fields on device
  

  subroutine allocate_single_level_GPU(this, ncol, nalbedobands, nemisbands, &
&                           use_sw_albedo_direct, is_simple_surface, lacc)
use yomhook
class(single_level_type), intent(inout) :: this
integer,                  intent(in)    :: ncol, nalbedobands, nemisbands
logical,        optional, intent(in)    :: use_sw_albedo_direct
logical,        optional, intent(in)    :: is_simple_surface

logical, intent (in) :: lacc










end subroutine allocate_single_level_GPU

  subroutine deallocate_single_level_GPU(this, lacc)
use yomhook
class(single_level_type), intent(inout) :: this

logical, intent (in) :: lacc










end subroutine deallocate_single_level_GPU

  subroutine init_seed_simple_GPU(this, istartcol, iendcol, lacc)
class(single_level_type), intent(inout) :: this
integer, intent(in)                     :: istartcol, iendcol
logical, optional, intent(in)           :: lacc








end subroutine init_seed_simple_GPU

  subroutine get_albedos_GPU(this, istartcol, iendcol, config, &
&                 sw_albedo_direct, sw_albedo_diffuse, lw_albedo, lacc)
use radiation_config
use radiation_io
use yomhook
class(single_level_type), intent(in) :: this
type(config_type),        intent(in) :: config
integer,                  intent(in) :: istartcol, iendcol



real(jprb), intent(out), optional &
&  :: lw_albedo(config%n_g_lw, istartcol:iendcol)



real(jprb), intent(out), dimension(config%n_g_sw, istartcol:iendcol) &
&  :: sw_albedo_direct, sw_albedo_diffuse








logical, intent (in) :: lacc







end subroutine get_albedos_GPU

  function out_of_physical_bounds_GPU(this, istartcol, iendcol, do_fix, lacc) result(is_bad)
use yomhook
use radiation_check
class(single_level_type), intent(inout) :: this
integer,         optional,intent(in) :: istartcol, iendcol
logical,         optional,intent(in) :: do_fix
logical                              :: is_bad


logical, intent (in) :: lacc




end function out_of_physical_bounds_GPU

  subroutine create_device_GPU(this, lacc)
class(single_level_type), intent(inout) :: this
logical, intent (in) :: lacc
















end subroutine create_device_GPU

  subroutine update_host_GPU(this, lacc)
class(single_level_type), intent(inout) :: this
logical, intent (in) :: lacc
















end subroutine update_host_GPU

  subroutine update_device_GPU(this, lacc)
class(single_level_type), intent(inout) :: this
logical, intent (in) :: lacc
















end subroutine update_device_GPU

  subroutine delete_device_GPU(this, lacc)
class(single_level_type), intent(inout) :: this
logical, intent (in) :: lacc
















end subroutine delete_device_GPU

  subroutine allocate_single_level_CPU(this, ncol, nalbedobands, nemisbands, &
&                           use_sw_albedo_direct, is_simple_surface)
use yomhook
class(single_level_type), intent(inout) :: this
integer,                  intent(in)    :: ncol, nalbedobands, nemisbands
logical,        optional, intent(in)    :: use_sw_albedo_direct
logical,        optional, intent(in)    :: is_simple_surface











end subroutine allocate_single_level_CPU

  subroutine deallocate_single_level_CPU(this)
use yomhook
class(single_level_type), intent(inout) :: this











end subroutine deallocate_single_level_CPU

  subroutine init_seed_simple_CPU(this, istartcol, iendcol, lacc)
class(single_level_type), intent(inout) :: this
integer, intent(in)                     :: istartcol, iendcol
logical, optional, intent(in)           :: lacc





end subroutine init_seed_simple_CPU

  subroutine get_albedos_CPU(this, istartcol, iendcol, config, &
&                 sw_albedo_direct, sw_albedo_diffuse, lw_albedo)
use radiation_config
use radiation_io
use yomhook
class(single_level_type), intent(in) :: this
type(config_type),        intent(in) :: config
integer,                  intent(in) :: istartcol, iendcol



real(jprb), intent(out), optional &
&  :: lw_albedo(config%n_g_lw, istartcol:iendcol)



real(jprb), intent(out), dimension(config%n_g_sw, istartcol:iendcol) &
&  :: sw_albedo_direct, sw_albedo_diffuse












end subroutine get_albedos_CPU

  function out_of_physical_bounds_CPU(this, istartcol, iendcol, do_fix) result(is_bad)
use yomhook
use radiation_check
class(single_level_type), intent(inout) :: this
integer,         optional,intent(in) :: istartcol, iendcol
logical,         optional,intent(in) :: do_fix
logical                              :: is_bad






end function out_of_physical_bounds_CPU

end module radiation_single_level

