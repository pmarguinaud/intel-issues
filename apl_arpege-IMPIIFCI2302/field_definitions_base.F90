! -- Field definitions base - prototype AJG 24/10/2012 --
!
! These are the building blocks for creating a field namespace
!
MODULE FIELD_DEFINITIONS_BASE

USE PARKIND1, ONLY: JPIM, JPRB
USE YOMLUN,   ONLY : NULOUT, NULERR
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK, JPHOOK

IMPLICIT NONE
PUBLIC
! Modes of attachment to GFL/GMV etc. NFTBC
INTEGER(KIND=JPIM), PARAMETER :: JP_T9=1, JP_T0=2, JP_T1=3,&
 & JP_T9_DL=11, JP_T9_DM=12, JP_T0_DL=21, JP_T0_DM=22, &
 & JP_PC=4,JP_PT=5

INTEGER(KIND=JPIM), PARAMETER :: JP_NAME_MAX_LEN = 16
INTEGER(KIND=JPIM), PARAMETER :: JP_COMMENTS_MAX_LEN = 128

INTEGER(KIND=JPIM), PARAMETER :: JP_NECV_1D_MAX = 1
INTEGER(KIND=JPIM), PARAMETER :: JP_NECV_2D_MAX = 400
INTEGER(KIND=JPIM), PARAMETER :: JP_NECV_3D_MAX = 8


! Stores most of the basic details of each variable, including
! attributes if we decide that is necessary.
TYPE TYPE_FVAR
  CHARACTER(LEN=JP_NAME_MAX_LEN)     :: NAME='XXX'
  CHARACTER(LEN=JP_COMMENTS_MAX_LEN) :: COMMENTS='YYY'
  INTEGER(KIND=JPIM) :: NDIMS=0  ! Number of dimensions
  INTEGER(KIND=JPIM) :: D2TYPE=1 ! Type of second dimension 
  INTEGER(KIND=JPIM) :: D3TYPE=1
!  INTEGER(KIND=JPIM) :: NDIM3=1  ! Third dimension
  INTEGER(KIND=JPIM) :: IGRIBCODE = -999 ! GRIB code
  REAL(KIND=JPRB)    :: R         = 0.0_JPRB !Specific gas constant
  REAL(KIND=JPRB)    :: RCP       = 0.0_JPRB !vapour calorific capacity at constant pressure
  INTEGER(KIND=JPIM) :: IGFLGMV=-1 ! Type of old storage (temporary)
  LOGICAL            :: LDEFINED=.FALSE.
END TYPE TYPE_FVAR

! Used by the field access mechanism - every field_access type should have one
! "class / extends" approach may be preferred in a F2003 version, but if dynamic polym, maybe not.
TYPE TYPE_CONTROL
  INTEGER(KIND=JPIM)          :: IACCESS_TOKEN 
  INTEGER(KIND=JPIM)          :: IBLOCK
END TYPE TYPE_CONTROL

TYPE, ABSTRACT :: FIELD_METADATA_BASE
  CONTAINS
  PROCEDURE (FIELD_SET_METADATA), DEFERRED :: FIELD_SET_METADATA
  PROCEDURE (FIELD_GET_CLEVTYPE), DEFERRED :: FIELD_GET_CLEVTYPE
END TYPE FIELD_METADATA_BASE

ABSTRACT INTERFACE
  SUBROUTINE FIELD_SET_METADATA(THIS, METADATA, KLEVELTYPES,KDIM3TYPES)
    USE PARKIND1, ONLY: JPIM
    IMPORT FIELD_METADATA_BASE, TYPE_FVAR
    CLASS(FIELD_METADATA_BASE), INTENT(IN)    :: THIS
    TYPE(TYPE_FVAR), ALLOCATABLE,INTENT(INOUT) :: METADATA(:)
    INTEGER(KIND=JPIM),         INTENT(  OUT) :: KLEVELTYPES
    INTEGER(KIND=JPIM),         INTENT(  OUT) :: KDIM3TYPES
  END SUBROUTINE FIELD_SET_METADATA
END INTERFACE

ABSTRACT INTERFACE
  FUNCTION FIELD_GET_CLEVTYPE(THIS, KLEVELTYPE) RESULT(CLEVTYPE)
    USE PARKIND1, ONLY: JPIM
    IMPORT FIELD_METADATA_BASE
    CLASS(FIELD_METADATA_BASE), INTENT(IN) :: THIS
    INTEGER(KIND=JPIM), INTENT(IN) :: KLEVELTYPE
    CHARACTER(LEN=3) :: CLEVTYPE
  END FUNCTION FIELD_GET_CLEVTYPE
END INTERFACE

TYPE, ABSTRACT :: FIELD_ACCESS_BASE
  TYPE(TYPE_CONTROL)          :: ACCESS_CONTROL
  INTEGER(KIND=JPIM), POINTER :: FIELDS(:) => NULL()
  INTEGER(KIND=JPIM)          :: ITERATOR_COUNT = 0
  REAL(KIND=JPRB)   , POINTER :: RR1(:) => NULL()
  REAL(KIND=JPRB)   , POINTER :: RR2(:,:) => NULL()
  CONTAINS
  PROCEDURE (FIELD_MAP_STORAGE), DEFERRED :: FIELD_MAP_STORAGE
END TYPE FIELD_ACCESS_BASE

ABSTRACT INTERFACE
  SUBROUTINE FIELD_MAP_STORAGE(THIS, KID, STORAGE_1D, STORAGE_2D, STORAGE_3D, LD_NULLIFY)
    USE PARKIND1, ONLY: JPIM, JPRB
    IMPORT FIELD_ACCESS_BASE
    CLASS(FIELD_ACCESS_BASE),          INTENT(INOUT) :: THIS
    INTEGER(KIND=JPIM),                INTENT(IN)    :: KID
    REAL(KIND=JPRB), OPTIONAL, TARGET, INTENT(IN)    :: STORAGE_1D(:), STORAGE_2D(:,:), STORAGE_3D(:,:,:)
    LOGICAL, OPTIONAL,                 INTENT(IN)    :: LD_NULLIFY 
  END SUBROUTINE FIELD_MAP_STORAGE
END INTERFACE

#ifndef FIELD_MOD_TEST
#include "abor1.intfb.h"
#endif

CONTAINS
!====================================================================================
SUBROUTINE SET_FVAR(FVAR,KFID,CDNAME,KDIMS,KLEVEL_TYPE,COMMENTS,KGFLGMV,&
& PR,PRCP,KDIM3_TYPE,KGRIB)
! Setup routine for field definition
TYPE(TYPE_FVAR),    INTENT(INOUT) :: FVAR(:)
INTEGER(KIND=JPIM), INTENT(IN)    :: KFID, KDIMS, KLEVEL_TYPE
CHARACTER(LEN=*),   INTENT(IN)    :: CDNAME, COMMENTS
INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN) :: KGFLGMV
REAL(KIND=JPRB),OPTIONAL,INTENT(IN)  :: PR
REAL(KIND=JPRB),OPTIONAL,INTENT(IN)  :: PRCP 
INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN) :: KDIM3_TYPE ! Size of third dimension for 3D variable
INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN) :: KGRIB ! Grid parameter code
INTEGER(KIND=JPIM) :: ILEN
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_DEFINITIONS_BASE:SET_FVAR',0,ZHOOK_HANDLE)
IF(KFID > SIZE(FVAR) .OR. KFID < 1) THEN
  WRITE(0,*) 'FIELD_DEFINITIONS_BASE:SET_FVAR - ID OUT OF RANGE:', SIZE(FVAR), KFID
  CALL ABOR1('FIELD_DEFINITIONS_BASE:SET_FVAR - ID OUT OF RANGE:')
ENDIF

FVAR(KFID)%LDEFINED = .TRUE.
! Number of dimensions; type of vertical level
FVAR(KFID)%NDIMS=KDIMS
FVAR(KFID)%D2TYPE=KLEVEL_TYPE

! Short field name (should be identical to "fid" name
ILEN = LEN(CDNAME)
FVAR(KFID)%NAME = CDNAME(1:MIN(ILEN,JP_NAME_MAX_LEN))  

! Comments
ILEN = LEN(COMMENTS)
FVAR(KFID)%COMMENTS = COMMENTS(1:MIN(ILEN,JP_COMMENTS_MAX_LEN))  
IF(PRESENT(KGFLGMV)) THEN
  FVAR(KFID)%IGFLGMV = KGFLGMV
ELSE
  FVAR(KFID)%IGFLGMV = 0
ENDIF
IF(PRESENT(PR))  FVAR(KFID)%R = PR
IF(PRESENT(PRCP))  FVAR(KFID)%RCP = PRCP
IF(PRESENT(KGRIB)) FVAR(KFID)%IGRIBCODE=KGRIB
IF(FVAR(KFID)%NDIMS == 3) THEN
  IF(.NOT.PRESENT(KDIM3_TYPE)) THEN
    WRITE(0,*) 'Must give size of 3rd dimension for FID ', KFID, FVAR(KFID)%NAME
    CALL ABOR1('FIELD_DEFINITIONS_BASE:SET_FVAR - Must give size of 3rd dimension')
  ENDIF
  FVAR(KFID)%D3TYPE = KDIM3_TYPE
ENDIF
IF (LHOOK) CALL DR_HOOK('FIELD_DEFINITIONS_BASE:SET_FVAR',1,ZHOOK_HANDLE)

!WRITE(NULOUT,*) 'FVAR ',KFID,FVAR(KFID)%NAME,FVAR(KFID)%IGFLGMV,FVAR(KFID)%NDIMS,FVAR(KFID)%RCP

END SUBROUTINE SET_FVAR
!====================================================================================
SUBROUTINE RESET_FVAR(FVAR,KFID,CDNAME,COMMENTS,PR,PRCP,KGRIB)
! Setup routine for field definition
TYPE(TYPE_FVAR),    INTENT(INOUT) :: FVAR(:)
INTEGER(KIND=JPIM), INTENT(IN)    :: KFID
CHARACTER(LEN=*),OPTIONAL,INTENT(IN)    :: CDNAME, COMMENTS
REAL(KIND=JPRB),OPTIONAL,INTENT(IN)  :: PR
REAL(KIND=JPRB),OPTIONAL,INTENT(IN)  :: PRCP 
INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN) :: KGRIB ! Grid parameter code

INTEGER(KIND=JPIM) :: ILEN

IF(KFID > SIZE(FVAR) .OR. KFID < 1) THEN
  WRITE(0,*) 'FIELD_DEFINITIONS_BASE:RESET_FVAR - ID OUT OF RANGE:', SIZE(FVAR), KFID
  CALL ABOR1('FIELD_DEFINITIONS_BASE:RESET_FVAR - ID OUT OF RANGE:')
ENDIF


! Short field name (should be identical to "fid" name
IF(PRESENT(CDNAME)) THEN
  ILEN = LEN(CDNAME)
  FVAR(KFID)%NAME = CDNAME(1:MIN(ILEN,JP_NAME_MAX_LEN))
ENDIF  

! Comments
IF(PRESENT(COMMENTS)) THEN
  ILEN = LEN(COMMENTS)
  FVAR(KFID)%COMMENTS = COMMENTS(1:MIN(ILEN,JP_COMMENTS_MAX_LEN))  
ENDIF
IF(PRESENT(PR))  FVAR(KFID)%R = PR
IF(PRESENT(PRCP))  FVAR(KFID)%RCP = PRCP
IF(PRESENT(KGRIB)) FVAR(KFID)%IGRIBCODE=KGRIB

WRITE(NULOUT,*) 'FVAR RESET ',KFID,FVAR(KFID)%NAME,FVAR(KFID)%IGFLGMV,FVAR(KFID)%NDIMS,FVAR(KFID)%IGRIBCODE

END SUBROUTINE RESET_FVAR
!====================================================================================

SUBROUTINE PRINT_NAMESPACE(FVAR)
! Print field definition
TYPE(TYPE_FVAR),    INTENT(IN) :: FVAR(:)
INTEGER(KIND=JPIM) :: JFID
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_DEFINITIONS_BASE:PRINT_NAMESPACE',0,ZHOOK_HANDLE)
WRITE(NULOUT,*) ' STANDARD FIELD DEFINITIONS ',SIZE(FVAR)
DO JFID=1,SIZE(FVAR)
  IF(FVAR(JFID)%LDEFINED) THEN
    WRITE(NULOUT,'(1X,I4,1X,A8,1X,I3,1X,A)') JFID,FVAR(JFID)%NAME,FVAR(JFID)%NDIMS,TRIM(FVAR(JFID)%COMMENTS)
  ENDIF
ENDDO
IF (LHOOK) CALL DR_HOOK('FIELD_DEFINITIONS_BASE:PRINT_NAMESPACE',1,ZHOOK_HANDLE)


END SUBROUTINE PRINT_NAMESPACE

!====================================================================================
FUNCTION GETFID(FVAR,CDNAME)
INTEGER(KIND=JPIM) :: GETFID
TYPE(TYPE_FVAR), INTENT(IN) :: FVAR(:)
CHARACTER(LEN=*),INTENT(IN) :: CDNAME
INTEGER(KIND=JPIM) :: JFID,IFID
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELD_DEFINITIONS_BASE:GETFID',0,ZHOOK_HANDLE)
IFID = -1
DO JFID=1,SIZE(FVAR)
  IF(FVAR(JFID)%LDEFINED) THEN
    IF(TRIM(FVAR(JFID)%NAME) == TRIM(CDNAME)) THEN
      IFID = JFID
      EXIT
    ENDIF
  ENDIF
ENDDO
IF(IFID == -1) THEN
  WRITE(NULOUT,*) 'FIELD_DEFINITIONS_BASE:GETFID - FIELD NAME UNKNOWN ',CDNAME
  CALL ABOR1('FIELD_DEFINITIONS_BASE:GETFID - FIELD NAME UNKNOWN')
ENDIF
GETFID = IFID
IF (LHOOK) CALL DR_HOOK('FIELD_DEFINITIONS_BASE:GETFID',1,ZHOOK_HANDLE)
END FUNCTION GETFID

!====================================================================================
END MODULE FIELD_DEFINITIONS_BASE

