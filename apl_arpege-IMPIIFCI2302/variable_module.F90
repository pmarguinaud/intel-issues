! Rank and shape definitions for simple templating

MODULE VARIABLE_MODULE
  ! Base class definition of VARIABLE types that manages configuration
  ! and metadata for individual variables and associates them with the
  ! respective FIELDS objects that store the data.

USE PARKIND1, ONLY: JPIM, JPRB, JPRD
USE FIELD_MODULE, ONLY: FIELD_2RB, FIELD_3RB, FIELD_4RB
USE FIELD_MODULE, ONLY: FIELD_2RD, FIELD_3RD, FIELD_4RD
USE YOM_YGFL, ONLY: TYPE_GFL_COMP

IMPLICIT NONE

TYPE, ABSTRACT :: VARIABLE_BASE
  ! Description and definition of a scientific variable that stores
  ! its associated data in one or more underlying fields, eg. for timestepping.

  ! Generic metadata like names and IDs
  CHARACTER(LEN=16)  :: NAME                  ! Primary name used for indexing
  CHARACTER(LEN=16)  :: CNAME     = ''        ! ARPEGE field name
  INTEGER(KIND=JPIM) :: IGRBCODE  = -999      ! GRIB code

  ! Flags that define the behaviour of the field variable
  LOGICAL            :: LACTIVE   = .FALSE.   ! Field in use
  LOGICAL            :: LT1       = .FALSE.   ! Field in t+dt GFL
  LOGICAL            :: LT9       = .FALSE.   ! Field in t-dt GFL
  LOGICAL            :: LPH9      = .FALSE.   ! Field in t-dt physics
  LOGICAL            :: LDL       = .FALSE.   ! Field has zontal derivative
  LOGICAL            :: LDM       = .FALSE.   ! Field has meridional derivative
  LOGICAL            :: LDL9      = .FALSE.   ! Field has zontal derivative at t-dt
  LOGICAL            :: LDM9      = .FALSE.   ! Field has meridional derivative at t-dt
  LOGICAL            :: LPC_PH    = .FALSE.   
  LOGICAL            :: LADV      = .FALSE.   ! Field advected or not
  LOGICAL            :: LGP       = .FALSE.   
  LOGICAL            :: LWATER    = .FALSE.   
  LOGICAL            :: LTHERMACT = .FALSE.   
  LOGICAL            :: LCDERS    = .FALSE.   
  REAL (KIND=JPRB)   :: RCP       = 0._JPRB
  REAL (KIND=JPRB)   :: R         = 0._JPRB

  TYPE (TYPE_GFL_COMP) :: YCOMP

  ! TODO: Storage backend for Atlas (guard by #ifdef)

CONTAINS
  PROCEDURE(VARIABLE_BASE_FINAL), DEFERRED :: FINAL
END TYPE VARIABLE_BASE

ABSTRACT INTERFACE
  SUBROUTINE VARIABLE_BASE_FINAL(SELF)
    IMPORT :: VARIABLE_BASE
    CLASS(VARIABLE_BASE) :: SELF
  END SUBROUTINE VARIABLE_BASE_FINAL
END INTERFACE


TYPE, EXTENDS(VARIABLE_BASE) :: VARIABLE_2RB
  ! TODO: Allocation-specific metadata, like shapes and dimensions
  ! Note that storing things like NLEV would break templating

  ! Array view pointers, to be set up from associated fields
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: P(:)  => NULL()  ! Basic field at t
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: T0(:) => NULL()  ! Basic field at t (alias of P)
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: T1(:) => NULL()  ! Basic field at t+dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: T9(:) => NULL()  ! Basic field at t-dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PH9(:)=> NULL()  ! Basic field for physics
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DL(:) => NULL()  ! Zonal derivative field
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DM(:) => NULL()  ! Meridional derivative field
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DL9(:) => NULL()  ! Zonal derivative field at t-dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DM9(:) => NULL()  ! Meridional derivative field at t-dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PC_PH(:) => NULL()  

  ! Pointers to associated FIELD objects
  CLASS (FIELD_2RB), POINTER :: FT0 => NULL()  ! Basic field at t
  CLASS (FIELD_2RB), POINTER :: FT1 => NULL()  ! Basic field at t+dt
  CLASS (FIELD_2RB), POINTER :: FT9 => NULL()  ! Basic field at t-dt
  CLASS (FIELD_2RB), POINTER :: FPH9 => NULL() ! Basic field for physics
  CLASS (FIELD_2RB), POINTER :: FDL => NULL()  ! Zonal derivative field
  CLASS (FIELD_2RB), POINTER :: FDM => NULL()  ! Meridional derivative field
  CLASS (FIELD_2RB), POINTER :: FDL9 => NULL() ! Zonal derivative field at t-dt
  CLASS (FIELD_2RB), POINTER :: FDM9 => NULL() ! Meridional derivative field at t-dt
  CLASS (FIELD_2RB), POINTER :: FPC_PH => NULL() 

CONTAINS
  PROCEDURE :: UPDATE_VIEW => VARIABLE_2RB_UPDATE_VIEW
  PROCEDURE :: CLONE => VARIABLE_2RB_CLONE
  PROCEDURE :: FINAL => VARIABLE_2RB_FINAL
  ! Timestepping utilities
  PROCEDURE :: PH9TOT0 => VARIABLE_2RB_PH9TOT0
  PROCEDURE :: PH9TOT9 => VARIABLE_2RB_PH9TOT9
END TYPE VARIABLE_2RB


TYPE, EXTENDS(VARIABLE_BASE) :: VARIABLE_3RB
  ! TODO: Allocation-specific metadata, like shapes and dimensions
  ! Note that storing things like NLEV would break templating

  ! Array view pointers, to be set up from associated fields
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: P(:,:)  => NULL()  ! Basic field at t
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: T0(:,:) => NULL()  ! Basic field at t (alias of P)
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: T1(:,:) => NULL()  ! Basic field at t+dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: T9(:,:) => NULL()  ! Basic field at t-dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PH9(:,:)=> NULL()  ! Basic field for physics
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DL(:,:) => NULL()  ! Zonal derivative field
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DM(:,:) => NULL()  ! Meridional derivative field
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DL9(:,:) => NULL()  ! Zonal derivative field at t-dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DM9(:,:) => NULL()  ! Meridional derivative field at t-dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PC_PH(:,:) => NULL()  

  ! Pointers to associated FIELD objects
  CLASS (FIELD_3RB), POINTER :: FT0 => NULL()  ! Basic field at t
  CLASS (FIELD_3RB), POINTER :: FT1 => NULL()  ! Basic field at t+dt
  CLASS (FIELD_3RB), POINTER :: FT9 => NULL()  ! Basic field at t-dt
  CLASS (FIELD_3RB), POINTER :: FPH9 => NULL() ! Basic field for physics
  CLASS (FIELD_3RB), POINTER :: FDL => NULL()  ! Zonal derivative field
  CLASS (FIELD_3RB), POINTER :: FDM => NULL()  ! Meridional derivative field
  CLASS (FIELD_3RB), POINTER :: FDL9 => NULL() ! Zonal derivative field at t-dt
  CLASS (FIELD_3RB), POINTER :: FDM9 => NULL() ! Meridional derivative field at t-dt
  CLASS (FIELD_3RB), POINTER :: FPC_PH => NULL() 

CONTAINS
  PROCEDURE :: UPDATE_VIEW => VARIABLE_3RB_UPDATE_VIEW
  PROCEDURE :: CLONE => VARIABLE_3RB_CLONE
  PROCEDURE :: FINAL => VARIABLE_3RB_FINAL
  ! Timestepping utilities
  PROCEDURE :: PH9TOT0 => VARIABLE_3RB_PH9TOT0
  PROCEDURE :: PH9TOT9 => VARIABLE_3RB_PH9TOT9
END TYPE VARIABLE_3RB


TYPE, EXTENDS(VARIABLE_BASE) :: VARIABLE_4RB
  ! TODO: Allocation-specific metadata, like shapes and dimensions
  ! Note that storing things like NLEV would break templating

  ! Array view pointers, to be set up from associated fields
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: P(:,:,:)  => NULL()  ! Basic field at t
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: T0(:,:,:) => NULL()  ! Basic field at t (alias of P)
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: T1(:,:,:) => NULL()  ! Basic field at t+dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: T9(:,:,:) => NULL()  ! Basic field at t-dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PH9(:,:,:)=> NULL()  ! Basic field for physics
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DL(:,:,:) => NULL()  ! Zonal derivative field
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DM(:,:,:) => NULL()  ! Meridional derivative field
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DL9(:,:,:) => NULL()  ! Zonal derivative field at t-dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DM9(:,:,:) => NULL()  ! Meridional derivative field at t-dt
  REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PC_PH(:,:,:) => NULL()  

  ! Pointers to associated FIELD objects
  CLASS (FIELD_4RB), POINTER :: FT0 => NULL()  ! Basic field at t
  CLASS (FIELD_4RB), POINTER :: FT1 => NULL()  ! Basic field at t+dt
  CLASS (FIELD_4RB), POINTER :: FT9 => NULL()  ! Basic field at t-dt
  CLASS (FIELD_4RB), POINTER :: FPH9 => NULL() ! Basic field for physics
  CLASS (FIELD_4RB), POINTER :: FDL => NULL()  ! Zonal derivative field
  CLASS (FIELD_4RB), POINTER :: FDM => NULL()  ! Meridional derivative field
  CLASS (FIELD_4RB), POINTER :: FDL9 => NULL() ! Zonal derivative field at t-dt
  CLASS (FIELD_4RB), POINTER :: FDM9 => NULL() ! Meridional derivative field at t-dt
  CLASS (FIELD_4RB), POINTER :: FPC_PH => NULL() 

CONTAINS
  PROCEDURE :: UPDATE_VIEW => VARIABLE_4RB_UPDATE_VIEW
  PROCEDURE :: CLONE => VARIABLE_4RB_CLONE
  PROCEDURE :: FINAL => VARIABLE_4RB_FINAL
  ! Timestepping utilities
  PROCEDURE :: PH9TOT0 => VARIABLE_4RB_PH9TOT0
  PROCEDURE :: PH9TOT9 => VARIABLE_4RB_PH9TOT9
END TYPE VARIABLE_4RB


TYPE, EXTENDS(VARIABLE_BASE) :: VARIABLE_2RD
  ! TODO: Allocation-specific metadata, like shapes and dimensions
  ! Note that storing things like NLEV would break templating

  ! Array view pointers, to be set up from associated fields
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: P(:)  => NULL()  ! Basic field at t
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: T0(:) => NULL()  ! Basic field at t (alias of P)
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: T1(:) => NULL()  ! Basic field at t+dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: T9(:) => NULL()  ! Basic field at t-dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: PH9(:)=> NULL()  ! Basic field for physics
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DL(:) => NULL()  ! Zonal derivative field
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DM(:) => NULL()  ! Meridional derivative field
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DL9(:) => NULL()  ! Zonal derivative field at t-dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DM9(:) => NULL()  ! Meridional derivative field at t-dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: PC_PH(:) => NULL()  

  ! Pointers to associated FIELD objects
  CLASS (FIELD_2RD), POINTER :: FT0 => NULL()  ! Basic field at t
  CLASS (FIELD_2RD), POINTER :: FT1 => NULL()  ! Basic field at t+dt
  CLASS (FIELD_2RD), POINTER :: FT9 => NULL()  ! Basic field at t-dt
  CLASS (FIELD_2RD), POINTER :: FPH9 => NULL() ! Basic field for physics
  CLASS (FIELD_2RD), POINTER :: FDL => NULL()  ! Zonal derivative field
  CLASS (FIELD_2RD), POINTER :: FDM => NULL()  ! Meridional derivative field
  CLASS (FIELD_2RD), POINTER :: FDL9 => NULL() ! Zonal derivative field at t-dt
  CLASS (FIELD_2RD), POINTER :: FDM9 => NULL() ! Meridional derivative field at t-dt
  CLASS (FIELD_2RD), POINTER :: FPC_PH => NULL() 

CONTAINS
  PROCEDURE :: UPDATE_VIEW => VARIABLE_2RD_UPDATE_VIEW
  PROCEDURE :: CLONE => VARIABLE_2RD_CLONE
  PROCEDURE :: FINAL => VARIABLE_2RD_FINAL
  ! Timestepping utilities
  PROCEDURE :: PH9TOT0 => VARIABLE_2RD_PH9TOT0
  PROCEDURE :: PH9TOT9 => VARIABLE_2RD_PH9TOT9
END TYPE VARIABLE_2RD


TYPE, EXTENDS(VARIABLE_BASE) :: VARIABLE_3RD
  ! TODO: Allocation-specific metadata, like shapes and dimensions
  ! Note that storing things like NLEV would break templating

  ! Array view pointers, to be set up from associated fields
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: P(:,:)  => NULL()  ! Basic field at t
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: T0(:,:) => NULL()  ! Basic field at t (alias of P)
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: T1(:,:) => NULL()  ! Basic field at t+dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: T9(:,:) => NULL()  ! Basic field at t-dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: PH9(:,:)=> NULL()  ! Basic field for physics
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DL(:,:) => NULL()  ! Zonal derivative field
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DM(:,:) => NULL()  ! Meridional derivative field
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DL9(:,:) => NULL()  ! Zonal derivative field at t-dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DM9(:,:) => NULL()  ! Meridional derivative field at t-dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: PC_PH(:,:) => NULL()  

  ! Pointers to associated FIELD objects
  CLASS (FIELD_3RD), POINTER :: FT0 => NULL()  ! Basic field at t
  CLASS (FIELD_3RD), POINTER :: FT1 => NULL()  ! Basic field at t+dt
  CLASS (FIELD_3RD), POINTER :: FT9 => NULL()  ! Basic field at t-dt
  CLASS (FIELD_3RD), POINTER :: FPH9 => NULL() ! Basic field for physics
  CLASS (FIELD_3RD), POINTER :: FDL => NULL()  ! Zonal derivative field
  CLASS (FIELD_3RD), POINTER :: FDM => NULL()  ! Meridional derivative field
  CLASS (FIELD_3RD), POINTER :: FDL9 => NULL() ! Zonal derivative field at t-dt
  CLASS (FIELD_3RD), POINTER :: FDM9 => NULL() ! Meridional derivative field at t-dt
  CLASS (FIELD_3RD), POINTER :: FPC_PH => NULL() 

CONTAINS
  PROCEDURE :: UPDATE_VIEW => VARIABLE_3RD_UPDATE_VIEW
  PROCEDURE :: CLONE => VARIABLE_3RD_CLONE
  PROCEDURE :: FINAL => VARIABLE_3RD_FINAL
  ! Timestepping utilities
  PROCEDURE :: PH9TOT0 => VARIABLE_3RD_PH9TOT0
  PROCEDURE :: PH9TOT9 => VARIABLE_3RD_PH9TOT9
END TYPE VARIABLE_3RD


TYPE, EXTENDS(VARIABLE_BASE) :: VARIABLE_4RD
  ! TODO: Allocation-specific metadata, like shapes and dimensions
  ! Note that storing things like NLEV would break templating

  ! Array view pointers, to be set up from associated fields
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: P(:,:,:)  => NULL()  ! Basic field at t
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: T0(:,:,:) => NULL()  ! Basic field at t (alias of P)
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: T1(:,:,:) => NULL()  ! Basic field at t+dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: T9(:,:,:) => NULL()  ! Basic field at t-dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: PH9(:,:,:)=> NULL()  ! Basic field for physics
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DL(:,:,:) => NULL()  ! Zonal derivative field
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DM(:,:,:) => NULL()  ! Meridional derivative field
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DL9(:,:,:) => NULL()  ! Zonal derivative field at t-dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: DM9(:,:,:) => NULL()  ! Meridional derivative field at t-dt
  REAL(KIND=JPRD), POINTER, CONTIGUOUS :: PC_PH(:,:,:) => NULL()  

  ! Pointers to associated FIELD objects
  CLASS (FIELD_4RD), POINTER :: FT0 => NULL()  ! Basic field at t
  CLASS (FIELD_4RD), POINTER :: FT1 => NULL()  ! Basic field at t+dt
  CLASS (FIELD_4RD), POINTER :: FT9 => NULL()  ! Basic field at t-dt
  CLASS (FIELD_4RD), POINTER :: FPH9 => NULL() ! Basic field for physics
  CLASS (FIELD_4RD), POINTER :: FDL => NULL()  ! Zonal derivative field
  CLASS (FIELD_4RD), POINTER :: FDM => NULL()  ! Meridional derivative field
  CLASS (FIELD_4RD), POINTER :: FDL9 => NULL() ! Zonal derivative field at t-dt
  CLASS (FIELD_4RD), POINTER :: FDM9 => NULL() ! Meridional derivative field at t-dt
  CLASS (FIELD_4RD), POINTER :: FPC_PH => NULL() 

CONTAINS
  PROCEDURE :: UPDATE_VIEW => VARIABLE_4RD_UPDATE_VIEW
  PROCEDURE :: CLONE => VARIABLE_4RD_CLONE
  PROCEDURE :: FINAL => VARIABLE_4RD_FINAL
  ! Timestepping utilities
  PROCEDURE :: PH9TOT0 => VARIABLE_4RD_PH9TOT0
  PROCEDURE :: PH9TOT9 => VARIABLE_4RD_PH9TOT9
END TYPE VARIABLE_4RD



INTERFACE VARIABLE_2RB
  MODULE PROCEDURE :: VARIABLE_2RB_INIT
  ! MODULE PROCEDURE :: VARIABLE_FROM_NAMELIST
END INTERFACE VARIABLE_2RB
INTERFACE VARIABLE_3RB
  MODULE PROCEDURE :: VARIABLE_3RB_INIT
  ! MODULE PROCEDURE :: VARIABLE_FROM_NAMELIST
END INTERFACE VARIABLE_3RB
INTERFACE VARIABLE_4RB
  MODULE PROCEDURE :: VARIABLE_4RB_INIT
  ! MODULE PROCEDURE :: VARIABLE_FROM_NAMELIST
END INTERFACE VARIABLE_4RB
INTERFACE VARIABLE_2RD
  MODULE PROCEDURE :: VARIABLE_2RD_INIT
  ! MODULE PROCEDURE :: VARIABLE_FROM_NAMELIST
END INTERFACE VARIABLE_2RD
INTERFACE VARIABLE_3RD
  MODULE PROCEDURE :: VARIABLE_3RD_INIT
  ! MODULE PROCEDURE :: VARIABLE_FROM_NAMELIST
END INTERFACE VARIABLE_3RD
INTERFACE VARIABLE_4RD
  MODULE PROCEDURE :: VARIABLE_4RD_INIT
  ! MODULE PROCEDURE :: VARIABLE_FROM_NAMELIST
END INTERFACE VARIABLE_4RD

INTERFACE ARGUMENT_VALUE
  ! Helper interface to resolve values of optional arguments with defaults
  MODULE PROCEDURE ARGUMENT_VALUE_REAL
  MODULE PROCEDURE ARGUMENT_VALUE_INTEGER
  MODULE PROCEDURE ARGUMENT_VALUE_STRING
  MODULE PROCEDURE ARGUMENT_VALUE_LOGICAL
END INTERFACE ARGUMENT_VALUE

CONTAINS

  FUNCTION ARGUMENT_VALUE_REAL(ARG, DEFAULT) RESULT(VAL)
    ! Helper function to resolve value for optional argument
    REAL(KIND=JPRB), OPTIONAL, INTENT(IN) :: ARG
    REAL(KIND=JPRB), INTENT(IN) :: DEFAULT
    REAL(KIND=JPRB) :: VAL

    IF (PRESENT(ARG)) THEN
      VAL = ARG
    ELSE
      VAL = DEFAULT
    END IF
  END FUNCTION ARGUMENT_VALUE_REAL

  FUNCTION ARGUMENT_VALUE_INTEGER(ARG, DEFAULT) RESULT(VAL)
    ! Helper function to resolve value for optional argument
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: ARG
    INTEGER(KIND=JPIM), INTENT(IN) :: DEFAULT
    INTEGER(KIND=JPIM) :: VAL

    IF (PRESENT(ARG)) THEN
      VAL = ARG
    ELSE
      VAL = DEFAULT
    END IF
  END FUNCTION ARGUMENT_VALUE_INTEGER

  FUNCTION ARGUMENT_VALUE_STRING(ARG, DEFAULT) RESULT(VAL)
    ! Helper function to resolve value for optional argument
    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: ARG
    CHARACTER(LEN=*), INTENT(IN) :: DEFAULT
    CHARACTER(:), ALLOCATABLE :: VAL

    IF (PRESENT(ARG)) THEN
      ALLOCATE(VAL, SOURCE=ARG)
    ELSE
      ALLOCATE(VAL, SOURCE=DEFAULT)
    END IF
  END FUNCTION ARGUMENT_VALUE_STRING

  FUNCTION ARGUMENT_VALUE_LOGICAL(ARG, DEFAULT) RESULT(VAL)
    ! Helper function to resolve value for optional argument
    LOGICAL, OPTIONAL, INTENT(IN) :: ARG
    LOGICAL, INTENT(IN) :: DEFAULT
    LOGICAL :: VAL

    IF (PRESENT(ARG)) THEN
      VAL = ARG
    ELSE
      VAL = DEFAULT
    END IF
  END FUNCTION ARGUMENT_VALUE_LOGICAL


  FUNCTION VARIABLE_2RB_INIT (NAME, CNAME, IGRBCODE, LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER,&
      & LTHERMACT, LCDERS, RCP, R) RESULT(SELF)
    USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
    ! Templated constructor that creates new instances
    TYPE(VARIABLE_2RB) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: CNAME
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: IGRBCODE
    LOGICAL, OPTIONAL, INTENT(IN) :: LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER, LTHERMACT, LCDERS
    REAL(KIND=JPRB), OPTIONAL, INTENT (IN) :: RCP, R

    SELF%NAME = NAME
    SELF%CNAME = ARGUMENT_VALUE(ARG=CNAME, DEFAULT=NAME)
    SELF%IGRBCODE = ARGUMENT_VALUE(ARG=IGRBCODE, DEFAULT=-999)
    SELF%LACTIVE = ARGUMENT_VALUE(ARG=LACTIVE, DEFAULT=.FALSE.)
    SELF%LADV = ARGUMENT_VALUE(ARG=LADV, DEFAULT=.FALSE.)
    SELF%LT1 = ARGUMENT_VALUE(ARG=LT1, DEFAULT=.FALSE.)
    SELF%LT9 = ARGUMENT_VALUE(ARG=LT9, DEFAULT=.FALSE.)
    SELF%LPH9 = ARGUMENT_VALUE(ARG=LPH9, DEFAULT=.FALSE.)
    SELF%LDL = ARGUMENT_VALUE(ARG=LDL, DEFAULT=.FALSE.)
    SELF%LDM = ARGUMENT_VALUE(ARG=LDM, DEFAULT=.FALSE.)
    SELF%LDL9 = ARGUMENT_VALUE(ARG=LDL9, DEFAULT=.FALSE.)
    SELF%LDM9 = ARGUMENT_VALUE(ARG=LDM9, DEFAULT=.FALSE.)
    SELF%LPC_PH = ARGUMENT_VALUE(ARG=LPC_PH, DEFAULT=.FALSE.)
    SELF%LGP = ARGUMENT_VALUE(ARG=LGP, DEFAULT=.FALSE.)
    SELF%LWATER = ARGUMENT_VALUE(ARG=LWATER, DEFAULT=.FALSE.)
    SELF%LTHERMACT = ARGUMENT_VALUE(ARG=LTHERMACT, DEFAULT=.FALSE.)
    SELF%LCDERS = ARGUMENT_VALUE(ARG=LCDERS, DEFAULT=.FALSE.)
    SELF%RCP = ARGUMENT_VALUE(ARG=RCP, DEFAULT=IEEE_VALUE (RCP, IEEE_QUIET_NAN))
    SELF%R = ARGUMENT_VALUE(ARG=R, DEFAULT=IEEE_VALUE (R, IEEE_QUIET_NAN))
  END FUNCTION VARIABLE_2RB_INIT

  FUNCTION VARIABLE_3RB_INIT (NAME, CNAME, IGRBCODE, LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER,&
      & LTHERMACT, LCDERS, RCP, R) RESULT(SELF)
    USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
    ! Templated constructor that creates new instances
    TYPE(VARIABLE_3RB) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: CNAME
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: IGRBCODE
    LOGICAL, OPTIONAL, INTENT(IN) :: LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER, LTHERMACT, LCDERS
    REAL(KIND=JPRB), OPTIONAL, INTENT (IN) :: RCP, R

    SELF%NAME = NAME
    SELF%CNAME = ARGUMENT_VALUE(ARG=CNAME, DEFAULT=NAME)
    SELF%IGRBCODE = ARGUMENT_VALUE(ARG=IGRBCODE, DEFAULT=-999)
    SELF%LACTIVE = ARGUMENT_VALUE(ARG=LACTIVE, DEFAULT=.FALSE.)
    SELF%LADV = ARGUMENT_VALUE(ARG=LADV, DEFAULT=.FALSE.)
    SELF%LT1 = ARGUMENT_VALUE(ARG=LT1, DEFAULT=.FALSE.)
    SELF%LT9 = ARGUMENT_VALUE(ARG=LT9, DEFAULT=.FALSE.)
    SELF%LPH9 = ARGUMENT_VALUE(ARG=LPH9, DEFAULT=.FALSE.)
    SELF%LDL = ARGUMENT_VALUE(ARG=LDL, DEFAULT=.FALSE.)
    SELF%LDM = ARGUMENT_VALUE(ARG=LDM, DEFAULT=.FALSE.)
    SELF%LDL9 = ARGUMENT_VALUE(ARG=LDL9, DEFAULT=.FALSE.)
    SELF%LDM9 = ARGUMENT_VALUE(ARG=LDM9, DEFAULT=.FALSE.)
    SELF%LPC_PH = ARGUMENT_VALUE(ARG=LPC_PH, DEFAULT=.FALSE.)
    SELF%LGP = ARGUMENT_VALUE(ARG=LGP, DEFAULT=.FALSE.)
    SELF%LWATER = ARGUMENT_VALUE(ARG=LWATER, DEFAULT=.FALSE.)
    SELF%LTHERMACT = ARGUMENT_VALUE(ARG=LTHERMACT, DEFAULT=.FALSE.)
    SELF%LCDERS = ARGUMENT_VALUE(ARG=LCDERS, DEFAULT=.FALSE.)
    SELF%RCP = ARGUMENT_VALUE(ARG=RCP, DEFAULT=IEEE_VALUE (RCP, IEEE_QUIET_NAN))
    SELF%R = ARGUMENT_VALUE(ARG=R, DEFAULT=IEEE_VALUE (R, IEEE_QUIET_NAN))
  END FUNCTION VARIABLE_3RB_INIT

  FUNCTION VARIABLE_4RB_INIT (NAME, CNAME, IGRBCODE, LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER,&
      & LTHERMACT, LCDERS, RCP, R) RESULT(SELF)
    USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
    ! Templated constructor that creates new instances
    TYPE(VARIABLE_4RB) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: CNAME
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: IGRBCODE
    LOGICAL, OPTIONAL, INTENT(IN) :: LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER, LTHERMACT, LCDERS
    REAL(KIND=JPRB), OPTIONAL, INTENT (IN) :: RCP, R

    SELF%NAME = NAME
    SELF%CNAME = ARGUMENT_VALUE(ARG=CNAME, DEFAULT=NAME)
    SELF%IGRBCODE = ARGUMENT_VALUE(ARG=IGRBCODE, DEFAULT=-999)
    SELF%LACTIVE = ARGUMENT_VALUE(ARG=LACTIVE, DEFAULT=.FALSE.)
    SELF%LADV = ARGUMENT_VALUE(ARG=LADV, DEFAULT=.FALSE.)
    SELF%LT1 = ARGUMENT_VALUE(ARG=LT1, DEFAULT=.FALSE.)
    SELF%LT9 = ARGUMENT_VALUE(ARG=LT9, DEFAULT=.FALSE.)
    SELF%LPH9 = ARGUMENT_VALUE(ARG=LPH9, DEFAULT=.FALSE.)
    SELF%LDL = ARGUMENT_VALUE(ARG=LDL, DEFAULT=.FALSE.)
    SELF%LDM = ARGUMENT_VALUE(ARG=LDM, DEFAULT=.FALSE.)
    SELF%LDL9 = ARGUMENT_VALUE(ARG=LDL9, DEFAULT=.FALSE.)
    SELF%LDM9 = ARGUMENT_VALUE(ARG=LDM9, DEFAULT=.FALSE.)
    SELF%LPC_PH = ARGUMENT_VALUE(ARG=LPC_PH, DEFAULT=.FALSE.)
    SELF%LGP = ARGUMENT_VALUE(ARG=LGP, DEFAULT=.FALSE.)
    SELF%LWATER = ARGUMENT_VALUE(ARG=LWATER, DEFAULT=.FALSE.)
    SELF%LTHERMACT = ARGUMENT_VALUE(ARG=LTHERMACT, DEFAULT=.FALSE.)
    SELF%LCDERS = ARGUMENT_VALUE(ARG=LCDERS, DEFAULT=.FALSE.)
    SELF%RCP = ARGUMENT_VALUE(ARG=RCP, DEFAULT=IEEE_VALUE (RCP, IEEE_QUIET_NAN))
    SELF%R = ARGUMENT_VALUE(ARG=R, DEFAULT=IEEE_VALUE (R, IEEE_QUIET_NAN))
  END FUNCTION VARIABLE_4RB_INIT

  FUNCTION VARIABLE_2RD_INIT (NAME, CNAME, IGRBCODE, LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER,&
      & LTHERMACT, LCDERS, RCP, R) RESULT(SELF)
    USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
    ! Templated constructor that creates new instances
    TYPE(VARIABLE_2RD) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: CNAME
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: IGRBCODE
    LOGICAL, OPTIONAL, INTENT(IN) :: LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER, LTHERMACT, LCDERS
    REAL(KIND=JPRB), OPTIONAL, INTENT (IN) :: RCP, R

    SELF%NAME = NAME
    SELF%CNAME = ARGUMENT_VALUE(ARG=CNAME, DEFAULT=NAME)
    SELF%IGRBCODE = ARGUMENT_VALUE(ARG=IGRBCODE, DEFAULT=-999)
    SELF%LACTIVE = ARGUMENT_VALUE(ARG=LACTIVE, DEFAULT=.FALSE.)
    SELF%LADV = ARGUMENT_VALUE(ARG=LADV, DEFAULT=.FALSE.)
    SELF%LT1 = ARGUMENT_VALUE(ARG=LT1, DEFAULT=.FALSE.)
    SELF%LT9 = ARGUMENT_VALUE(ARG=LT9, DEFAULT=.FALSE.)
    SELF%LPH9 = ARGUMENT_VALUE(ARG=LPH9, DEFAULT=.FALSE.)
    SELF%LDL = ARGUMENT_VALUE(ARG=LDL, DEFAULT=.FALSE.)
    SELF%LDM = ARGUMENT_VALUE(ARG=LDM, DEFAULT=.FALSE.)
    SELF%LDL9 = ARGUMENT_VALUE(ARG=LDL9, DEFAULT=.FALSE.)
    SELF%LDM9 = ARGUMENT_VALUE(ARG=LDM9, DEFAULT=.FALSE.)
    SELF%LPC_PH = ARGUMENT_VALUE(ARG=LPC_PH, DEFAULT=.FALSE.)
    SELF%LGP = ARGUMENT_VALUE(ARG=LGP, DEFAULT=.FALSE.)
    SELF%LWATER = ARGUMENT_VALUE(ARG=LWATER, DEFAULT=.FALSE.)
    SELF%LTHERMACT = ARGUMENT_VALUE(ARG=LTHERMACT, DEFAULT=.FALSE.)
    SELF%LCDERS = ARGUMENT_VALUE(ARG=LCDERS, DEFAULT=.FALSE.)
    SELF%RCP = ARGUMENT_VALUE(ARG=RCP, DEFAULT=IEEE_VALUE (RCP, IEEE_QUIET_NAN))
    SELF%R = ARGUMENT_VALUE(ARG=R, DEFAULT=IEEE_VALUE (R, IEEE_QUIET_NAN))
  END FUNCTION VARIABLE_2RD_INIT

  FUNCTION VARIABLE_3RD_INIT (NAME, CNAME, IGRBCODE, LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER,&
      & LTHERMACT, LCDERS, RCP, R) RESULT(SELF)
    USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
    ! Templated constructor that creates new instances
    TYPE(VARIABLE_3RD) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: CNAME
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: IGRBCODE
    LOGICAL, OPTIONAL, INTENT(IN) :: LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER, LTHERMACT, LCDERS
    REAL(KIND=JPRB), OPTIONAL, INTENT (IN) :: RCP, R

    SELF%NAME = NAME
    SELF%CNAME = ARGUMENT_VALUE(ARG=CNAME, DEFAULT=NAME)
    SELF%IGRBCODE = ARGUMENT_VALUE(ARG=IGRBCODE, DEFAULT=-999)
    SELF%LACTIVE = ARGUMENT_VALUE(ARG=LACTIVE, DEFAULT=.FALSE.)
    SELF%LADV = ARGUMENT_VALUE(ARG=LADV, DEFAULT=.FALSE.)
    SELF%LT1 = ARGUMENT_VALUE(ARG=LT1, DEFAULT=.FALSE.)
    SELF%LT9 = ARGUMENT_VALUE(ARG=LT9, DEFAULT=.FALSE.)
    SELF%LPH9 = ARGUMENT_VALUE(ARG=LPH9, DEFAULT=.FALSE.)
    SELF%LDL = ARGUMENT_VALUE(ARG=LDL, DEFAULT=.FALSE.)
    SELF%LDM = ARGUMENT_VALUE(ARG=LDM, DEFAULT=.FALSE.)
    SELF%LDL9 = ARGUMENT_VALUE(ARG=LDL9, DEFAULT=.FALSE.)
    SELF%LDM9 = ARGUMENT_VALUE(ARG=LDM9, DEFAULT=.FALSE.)
    SELF%LPC_PH = ARGUMENT_VALUE(ARG=LPC_PH, DEFAULT=.FALSE.)
    SELF%LGP = ARGUMENT_VALUE(ARG=LGP, DEFAULT=.FALSE.)
    SELF%LWATER = ARGUMENT_VALUE(ARG=LWATER, DEFAULT=.FALSE.)
    SELF%LTHERMACT = ARGUMENT_VALUE(ARG=LTHERMACT, DEFAULT=.FALSE.)
    SELF%LCDERS = ARGUMENT_VALUE(ARG=LCDERS, DEFAULT=.FALSE.)
    SELF%RCP = ARGUMENT_VALUE(ARG=RCP, DEFAULT=IEEE_VALUE (RCP, IEEE_QUIET_NAN))
    SELF%R = ARGUMENT_VALUE(ARG=R, DEFAULT=IEEE_VALUE (R, IEEE_QUIET_NAN))
  END FUNCTION VARIABLE_3RD_INIT

  FUNCTION VARIABLE_4RD_INIT (NAME, CNAME, IGRBCODE, LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER,&
      & LTHERMACT, LCDERS, RCP, R) RESULT(SELF)
    USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_VALUE, IEEE_QUIET_NAN
    ! Templated constructor that creates new instances
    TYPE(VARIABLE_4RD) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: CNAME
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: IGRBCODE
    LOGICAL, OPTIONAL, INTENT(IN) :: LACTIVE, LADV, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9, LPC_PH, LGP, LWATER, LTHERMACT, LCDERS
    REAL(KIND=JPRB), OPTIONAL, INTENT (IN) :: RCP, R

    SELF%NAME = NAME
    SELF%CNAME = ARGUMENT_VALUE(ARG=CNAME, DEFAULT=NAME)
    SELF%IGRBCODE = ARGUMENT_VALUE(ARG=IGRBCODE, DEFAULT=-999)
    SELF%LACTIVE = ARGUMENT_VALUE(ARG=LACTIVE, DEFAULT=.FALSE.)
    SELF%LADV = ARGUMENT_VALUE(ARG=LADV, DEFAULT=.FALSE.)
    SELF%LT1 = ARGUMENT_VALUE(ARG=LT1, DEFAULT=.FALSE.)
    SELF%LT9 = ARGUMENT_VALUE(ARG=LT9, DEFAULT=.FALSE.)
    SELF%LPH9 = ARGUMENT_VALUE(ARG=LPH9, DEFAULT=.FALSE.)
    SELF%LDL = ARGUMENT_VALUE(ARG=LDL, DEFAULT=.FALSE.)
    SELF%LDM = ARGUMENT_VALUE(ARG=LDM, DEFAULT=.FALSE.)
    SELF%LDL9 = ARGUMENT_VALUE(ARG=LDL9, DEFAULT=.FALSE.)
    SELF%LDM9 = ARGUMENT_VALUE(ARG=LDM9, DEFAULT=.FALSE.)
    SELF%LPC_PH = ARGUMENT_VALUE(ARG=LPC_PH, DEFAULT=.FALSE.)
    SELF%LGP = ARGUMENT_VALUE(ARG=LGP, DEFAULT=.FALSE.)
    SELF%LWATER = ARGUMENT_VALUE(ARG=LWATER, DEFAULT=.FALSE.)
    SELF%LTHERMACT = ARGUMENT_VALUE(ARG=LTHERMACT, DEFAULT=.FALSE.)
    SELF%LCDERS = ARGUMENT_VALUE(ARG=LCDERS, DEFAULT=.FALSE.)
    SELF%RCP = ARGUMENT_VALUE(ARG=RCP, DEFAULT=IEEE_VALUE (RCP, IEEE_QUIET_NAN))
    SELF%R = ARGUMENT_VALUE(ARG=R, DEFAULT=IEEE_VALUE (R, IEEE_QUIET_NAN))
  END FUNCTION VARIABLE_4RD_INIT


  FUNCTION VARIABLE_2RB_CLONE(SELF) RESULT(NEWOBJ)
    ! Clone (deep-copy) this VARIABLE object to replicate associated FIELD objects
    !
    ! This is required create per-thread replication of the data view pointers
    ! under the fields associated with this VARIABLE.
    CLASS(VARIABLE_2RB) :: SELF
    TYPE(VARIABLE_2RB) :: NEWOBJ

    NEWOBJ = SELF
    NEWOBJ%NAME = SELF%NAME
    NEWOBJ%CNAME = SELF%CNAME

!   IF (ASSOCIATED(SELF%FT0))  NEWOBJ%FT0 => SELF%FT0%CLONE()
!   IF (ASSOCIATED(SELF%FT1))  NEWOBJ%FT1 => SELF%FT1%CLONE()
!   IF (ASSOCIATED(SELF%FT9))  NEWOBJ%FT9 => SELF%FT9%CLONE()
!   IF (ASSOCIATED(SELF%FPH9)) NEWOBJ%FPH9=> SELF%FPH9%CLONE()
!   IF (ASSOCIATED(SELF%FDL))  NEWOBJ%FDL => SELF%FDL%CLONE()
!   IF (ASSOCIATED(SELF%FDM))  NEWOBJ%FDM => SELF%FDM%CLONE()
!   IF (ASSOCIATED(SELF%FDL9)) NEWOBJ%FDL9=> SELF%FDL9%CLONE()
!   IF (ASSOCIATED(SELF%FDM9)) NEWOBJ%FDM9=> SELF%FDM9%CLONE()
!   IF (ASSOCIATED(SELF%FPC_PH)) NEWOBJ%FPC_PH=> SELF%FPC_PH%CLONE()
  END FUNCTION VARIABLE_2RB_CLONE

  FUNCTION VARIABLE_3RB_CLONE(SELF) RESULT(NEWOBJ)
    ! Clone (deep-copy) this VARIABLE object to replicate associated FIELD objects
    !
    ! This is required create per-thread replication of the data view pointers
    ! under the fields associated with this VARIABLE.
    CLASS(VARIABLE_3RB) :: SELF
    TYPE(VARIABLE_3RB) :: NEWOBJ

    NEWOBJ = SELF
    NEWOBJ%NAME = SELF%NAME
    NEWOBJ%CNAME = SELF%CNAME

!   IF (ASSOCIATED(SELF%FT0))  NEWOBJ%FT0 => SELF%FT0%CLONE()
!   IF (ASSOCIATED(SELF%FT1))  NEWOBJ%FT1 => SELF%FT1%CLONE()
!   IF (ASSOCIATED(SELF%FT9))  NEWOBJ%FT9 => SELF%FT9%CLONE()
!   IF (ASSOCIATED(SELF%FPH9)) NEWOBJ%FPH9=> SELF%FPH9%CLONE()
!   IF (ASSOCIATED(SELF%FDL))  NEWOBJ%FDL => SELF%FDL%CLONE()
!   IF (ASSOCIATED(SELF%FDM))  NEWOBJ%FDM => SELF%FDM%CLONE()
!   IF (ASSOCIATED(SELF%FDL9)) NEWOBJ%FDL9=> SELF%FDL9%CLONE()
!   IF (ASSOCIATED(SELF%FDM9)) NEWOBJ%FDM9=> SELF%FDM9%CLONE()
!   IF (ASSOCIATED(SELF%FPC_PH)) NEWOBJ%FPC_PH=> SELF%FPC_PH%CLONE()
  END FUNCTION VARIABLE_3RB_CLONE

  FUNCTION VARIABLE_4RB_CLONE(SELF) RESULT(NEWOBJ)
    ! Clone (deep-copy) this VARIABLE object to replicate associated FIELD objects
    !
    ! This is required create per-thread replication of the data view pointers
    ! under the fields associated with this VARIABLE.
    CLASS(VARIABLE_4RB) :: SELF
    TYPE(VARIABLE_4RB) :: NEWOBJ

    NEWOBJ = SELF
    NEWOBJ%NAME = SELF%NAME
    NEWOBJ%CNAME = SELF%CNAME

!   IF (ASSOCIATED(SELF%FT0))  NEWOBJ%FT0 => SELF%FT0%CLONE()
!   IF (ASSOCIATED(SELF%FT1))  NEWOBJ%FT1 => SELF%FT1%CLONE()
!   IF (ASSOCIATED(SELF%FT9))  NEWOBJ%FT9 => SELF%FT9%CLONE()
!   IF (ASSOCIATED(SELF%FPH9)) NEWOBJ%FPH9=> SELF%FPH9%CLONE()
!   IF (ASSOCIATED(SELF%FDL))  NEWOBJ%FDL => SELF%FDL%CLONE()
!   IF (ASSOCIATED(SELF%FDM))  NEWOBJ%FDM => SELF%FDM%CLONE()
!   IF (ASSOCIATED(SELF%FDL9)) NEWOBJ%FDL9=> SELF%FDL9%CLONE()
!   IF (ASSOCIATED(SELF%FDM9)) NEWOBJ%FDM9=> SELF%FDM9%CLONE()
!   IF (ASSOCIATED(SELF%FPC_PH)) NEWOBJ%FPC_PH=> SELF%FPC_PH%CLONE()
  END FUNCTION VARIABLE_4RB_CLONE

  FUNCTION VARIABLE_2RD_CLONE(SELF) RESULT(NEWOBJ)
    ! Clone (deep-copy) this VARIABLE object to replicate associated FIELD objects
    !
    ! This is required create per-thread replication of the data view pointers
    ! under the fields associated with this VARIABLE.
    CLASS(VARIABLE_2RD) :: SELF
    TYPE(VARIABLE_2RD) :: NEWOBJ

    NEWOBJ = SELF
    NEWOBJ%NAME = SELF%NAME
    NEWOBJ%CNAME = SELF%CNAME

!   IF (ASSOCIATED(SELF%FT0))  NEWOBJ%FT0 => SELF%FT0%CLONE()
!   IF (ASSOCIATED(SELF%FT1))  NEWOBJ%FT1 => SELF%FT1%CLONE()
!   IF (ASSOCIATED(SELF%FT9))  NEWOBJ%FT9 => SELF%FT9%CLONE()
!   IF (ASSOCIATED(SELF%FPH9)) NEWOBJ%FPH9=> SELF%FPH9%CLONE()
!   IF (ASSOCIATED(SELF%FDL))  NEWOBJ%FDL => SELF%FDL%CLONE()
!   IF (ASSOCIATED(SELF%FDM))  NEWOBJ%FDM => SELF%FDM%CLONE()
!   IF (ASSOCIATED(SELF%FDL9)) NEWOBJ%FDL9=> SELF%FDL9%CLONE()
!   IF (ASSOCIATED(SELF%FDM9)) NEWOBJ%FDM9=> SELF%FDM9%CLONE()
!   IF (ASSOCIATED(SELF%FPC_PH)) NEWOBJ%FPC_PH=> SELF%FPC_PH%CLONE()
  END FUNCTION VARIABLE_2RD_CLONE

  FUNCTION VARIABLE_3RD_CLONE(SELF) RESULT(NEWOBJ)
    ! Clone (deep-copy) this VARIABLE object to replicate associated FIELD objects
    !
    ! This is required create per-thread replication of the data view pointers
    ! under the fields associated with this VARIABLE.
    CLASS(VARIABLE_3RD) :: SELF
    TYPE(VARIABLE_3RD) :: NEWOBJ

    NEWOBJ = SELF
    NEWOBJ%NAME = SELF%NAME
    NEWOBJ%CNAME = SELF%CNAME

!   IF (ASSOCIATED(SELF%FT0))  NEWOBJ%FT0 => SELF%FT0%CLONE()
!   IF (ASSOCIATED(SELF%FT1))  NEWOBJ%FT1 => SELF%FT1%CLONE()
!   IF (ASSOCIATED(SELF%FT9))  NEWOBJ%FT9 => SELF%FT9%CLONE()
!   IF (ASSOCIATED(SELF%FPH9)) NEWOBJ%FPH9=> SELF%FPH9%CLONE()
!   IF (ASSOCIATED(SELF%FDL))  NEWOBJ%FDL => SELF%FDL%CLONE()
!   IF (ASSOCIATED(SELF%FDM))  NEWOBJ%FDM => SELF%FDM%CLONE()
!   IF (ASSOCIATED(SELF%FDL9)) NEWOBJ%FDL9=> SELF%FDL9%CLONE()
!   IF (ASSOCIATED(SELF%FDM9)) NEWOBJ%FDM9=> SELF%FDM9%CLONE()
!   IF (ASSOCIATED(SELF%FPC_PH)) NEWOBJ%FPC_PH=> SELF%FPC_PH%CLONE()
  END FUNCTION VARIABLE_3RD_CLONE

  FUNCTION VARIABLE_4RD_CLONE(SELF) RESULT(NEWOBJ)
    ! Clone (deep-copy) this VARIABLE object to replicate associated FIELD objects
    !
    ! This is required create per-thread replication of the data view pointers
    ! under the fields associated with this VARIABLE.
    CLASS(VARIABLE_4RD) :: SELF
    TYPE(VARIABLE_4RD) :: NEWOBJ

    NEWOBJ = SELF
    NEWOBJ%NAME = SELF%NAME
    NEWOBJ%CNAME = SELF%CNAME

!   IF (ASSOCIATED(SELF%FT0))  NEWOBJ%FT0 => SELF%FT0%CLONE()
!   IF (ASSOCIATED(SELF%FT1))  NEWOBJ%FT1 => SELF%FT1%CLONE()
!   IF (ASSOCIATED(SELF%FT9))  NEWOBJ%FT9 => SELF%FT9%CLONE()
!   IF (ASSOCIATED(SELF%FPH9)) NEWOBJ%FPH9=> SELF%FPH9%CLONE()
!   IF (ASSOCIATED(SELF%FDL))  NEWOBJ%FDL => SELF%FDL%CLONE()
!   IF (ASSOCIATED(SELF%FDM))  NEWOBJ%FDM => SELF%FDM%CLONE()
!   IF (ASSOCIATED(SELF%FDL9)) NEWOBJ%FDL9=> SELF%FDL9%CLONE()
!   IF (ASSOCIATED(SELF%FDM9)) NEWOBJ%FDM9=> SELF%FDM9%CLONE()
!   IF (ASSOCIATED(SELF%FPC_PH)) NEWOBJ%FPC_PH=> SELF%FPC_PH%CLONE()
  END FUNCTION VARIABLE_4RD_CLONE


  SUBROUTINE VARIABLE_2RB_UPDATE_VIEW(SELF, BLOCK_INDEX)
    ! Update the internal data view pointers of all associated fields
    CLASS(VARIABLE_2RB) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    REAL(KIND=JPRB), TARGET, SAVE :: ZDUM(1)

    ! Set on-object data view pointers from storage FIELDS
    IF (ASSOCIATED(SELF%FT0))  THEN
      SELF%T0 => SELF%FT0%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T0 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT1))  THEN
      SELF%T1 => SELF%FT1%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T1 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT9))  THEN
      SELF%T9 => SELF%FT9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      SELF%PH9=> SELF%FPH9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PH9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL))  THEN
      SELF%DL => SELF%FDL%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM))  THEN
      SELF%DM => SELF%FDM%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      SELF%DL9=> SELF%FDL9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      SELF%DM9=> SELF%FDM9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      SELF%PC_PH=> SELF%FPC_PH%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PC_PH => ZDUM
    ENDIF
    SELF%P => SELF%T0  ! Alias T0 pointer
  END SUBROUTINE VARIABLE_2RB_UPDATE_VIEW

  SUBROUTINE VARIABLE_3RB_UPDATE_VIEW(SELF, BLOCK_INDEX)
    ! Update the internal data view pointers of all associated fields
    CLASS(VARIABLE_3RB) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    REAL(KIND=JPRB), TARGET, SAVE :: ZDUM(1, 1)

    ! Set on-object data view pointers from storage FIELDS
    IF (ASSOCIATED(SELF%FT0))  THEN
      SELF%T0 => SELF%FT0%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T0 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT1))  THEN
      SELF%T1 => SELF%FT1%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T1 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT9))  THEN
      SELF%T9 => SELF%FT9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      SELF%PH9=> SELF%FPH9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PH9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL))  THEN
      SELF%DL => SELF%FDL%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM))  THEN
      SELF%DM => SELF%FDM%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      SELF%DL9=> SELF%FDL9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      SELF%DM9=> SELF%FDM9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      SELF%PC_PH=> SELF%FPC_PH%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PC_PH => ZDUM
    ENDIF
    SELF%P => SELF%T0  ! Alias T0 pointer
  END SUBROUTINE VARIABLE_3RB_UPDATE_VIEW

  SUBROUTINE VARIABLE_4RB_UPDATE_VIEW(SELF, BLOCK_INDEX)
    ! Update the internal data view pointers of all associated fields
    CLASS(VARIABLE_4RB) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    REAL(KIND=JPRB), TARGET, SAVE :: ZDUM(1, 1, 1)

    ! Set on-object data view pointers from storage FIELDS
    IF (ASSOCIATED(SELF%FT0))  THEN
      SELF%T0 => SELF%FT0%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T0 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT1))  THEN
      SELF%T1 => SELF%FT1%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T1 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT9))  THEN
      SELF%T9 => SELF%FT9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      SELF%PH9=> SELF%FPH9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PH9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL))  THEN
      SELF%DL => SELF%FDL%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM))  THEN
      SELF%DM => SELF%FDM%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      SELF%DL9=> SELF%FDL9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      SELF%DM9=> SELF%FDM9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      SELF%PC_PH=> SELF%FPC_PH%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PC_PH => ZDUM
    ENDIF
    SELF%P => SELF%T0  ! Alias T0 pointer
  END SUBROUTINE VARIABLE_4RB_UPDATE_VIEW

  SUBROUTINE VARIABLE_2RD_UPDATE_VIEW(SELF, BLOCK_INDEX)
    ! Update the internal data view pointers of all associated fields
    CLASS(VARIABLE_2RD) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    REAL(KIND=JPRD), TARGET, SAVE :: ZDUM(1)

    ! Set on-object data view pointers from storage FIELDS
    IF (ASSOCIATED(SELF%FT0))  THEN
      SELF%T0 => SELF%FT0%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T0 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT1))  THEN
      SELF%T1 => SELF%FT1%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T1 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT9))  THEN
      SELF%T9 => SELF%FT9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      SELF%PH9=> SELF%FPH9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PH9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL))  THEN
      SELF%DL => SELF%FDL%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM))  THEN
      SELF%DM => SELF%FDM%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      SELF%DL9=> SELF%FDL9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      SELF%DM9=> SELF%FDM9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      SELF%PC_PH=> SELF%FPC_PH%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PC_PH => ZDUM
    ENDIF
    SELF%P => SELF%T0  ! Alias T0 pointer
  END SUBROUTINE VARIABLE_2RD_UPDATE_VIEW

  SUBROUTINE VARIABLE_3RD_UPDATE_VIEW(SELF, BLOCK_INDEX)
    ! Update the internal data view pointers of all associated fields
    CLASS(VARIABLE_3RD) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    REAL(KIND=JPRD), TARGET, SAVE :: ZDUM(1, 1)

    ! Set on-object data view pointers from storage FIELDS
    IF (ASSOCIATED(SELF%FT0))  THEN
      SELF%T0 => SELF%FT0%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T0 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT1))  THEN
      SELF%T1 => SELF%FT1%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T1 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT9))  THEN
      SELF%T9 => SELF%FT9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      SELF%PH9=> SELF%FPH9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PH9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL))  THEN
      SELF%DL => SELF%FDL%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM))  THEN
      SELF%DM => SELF%FDM%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      SELF%DL9=> SELF%FDL9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      SELF%DM9=> SELF%FDM9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      SELF%PC_PH=> SELF%FPC_PH%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PC_PH => ZDUM
    ENDIF
    SELF%P => SELF%T0  ! Alias T0 pointer
  END SUBROUTINE VARIABLE_3RD_UPDATE_VIEW

  SUBROUTINE VARIABLE_4RD_UPDATE_VIEW(SELF, BLOCK_INDEX)
    ! Update the internal data view pointers of all associated fields
    CLASS(VARIABLE_4RD) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    REAL(KIND=JPRD), TARGET, SAVE :: ZDUM(1, 1, 1)

    ! Set on-object data view pointers from storage FIELDS
    IF (ASSOCIATED(SELF%FT0))  THEN
      SELF%T0 => SELF%FT0%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T0 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT1))  THEN
      SELF%T1 => SELF%FT1%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T1 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FT9))  THEN
      SELF%T9 => SELF%FT9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%T9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      SELF%PH9=> SELF%FPH9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PH9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL))  THEN
      SELF%DL => SELF%FDL%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM))  THEN
      SELF%DM => SELF%FDM%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      SELF%DL9=> SELF%FDL9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DL9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      SELF%DM9=> SELF%FDM9%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%DM9 => ZDUM
    ENDIF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      SELF%PC_PH=> SELF%FPC_PH%GET_VIEW(BLOCK_INDEX)
    ELSE
      SELF%PC_PH => ZDUM
    ENDIF
    SELF%P => SELF%T0  ! Alias T0 pointer
  END SUBROUTINE VARIABLE_4RD_UPDATE_VIEW


  SUBROUTINE VARIABLE_2RB_PH9TOT0(SELF)
    ! Utility routine that aliases the PH9 field with T0
    CLASS(VARIABLE_2RB), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT0%PTR
  END SUBROUTINE VARIABLE_2RB_PH9TOT0

  SUBROUTINE VARIABLE_3RB_PH9TOT0(SELF)
    ! Utility routine that aliases the PH9 field with T0
    CLASS(VARIABLE_3RB), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT0%PTR
  END SUBROUTINE VARIABLE_3RB_PH9TOT0

  SUBROUTINE VARIABLE_4RB_PH9TOT0(SELF)
    ! Utility routine that aliases the PH9 field with T0
    CLASS(VARIABLE_4RB), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT0%PTR
  END SUBROUTINE VARIABLE_4RB_PH9TOT0

  SUBROUTINE VARIABLE_2RD_PH9TOT0(SELF)
    ! Utility routine that aliases the PH9 field with T0
    CLASS(VARIABLE_2RD), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT0%PTR
  END SUBROUTINE VARIABLE_2RD_PH9TOT0

  SUBROUTINE VARIABLE_3RD_PH9TOT0(SELF)
    ! Utility routine that aliases the PH9 field with T0
    CLASS(VARIABLE_3RD), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT0%PTR
  END SUBROUTINE VARIABLE_3RD_PH9TOT0

  SUBROUTINE VARIABLE_4RD_PH9TOT0(SELF)
    ! Utility routine that aliases the PH9 field with T0
    CLASS(VARIABLE_4RD), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT0%PTR
  END SUBROUTINE VARIABLE_4RD_PH9TOT0


  SUBROUTINE VARIABLE_2RB_PH9TOT9(SELF)
    ! Utility routine that aliases the PH9 field with T9
    CLASS(VARIABLE_2RB), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT9%PTR
  END SUBROUTINE VARIABLE_2RB_PH9TOT9

  SUBROUTINE VARIABLE_3RB_PH9TOT9(SELF)
    ! Utility routine that aliases the PH9 field with T9
    CLASS(VARIABLE_3RB), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT9%PTR
  END SUBROUTINE VARIABLE_3RB_PH9TOT9

  SUBROUTINE VARIABLE_4RB_PH9TOT9(SELF)
    ! Utility routine that aliases the PH9 field with T9
    CLASS(VARIABLE_4RB), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT9%PTR
  END SUBROUTINE VARIABLE_4RB_PH9TOT9

  SUBROUTINE VARIABLE_2RD_PH9TOT9(SELF)
    ! Utility routine that aliases the PH9 field with T9
    CLASS(VARIABLE_2RD), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT9%PTR
  END SUBROUTINE VARIABLE_2RD_PH9TOT9

  SUBROUTINE VARIABLE_3RD_PH9TOT9(SELF)
    ! Utility routine that aliases the PH9 field with T9
    CLASS(VARIABLE_3RD), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT9%PTR
  END SUBROUTINE VARIABLE_3RD_PH9TOT9

  SUBROUTINE VARIABLE_4RD_PH9TOT9(SELF)
    ! Utility routine that aliases the PH9 field with T9
    CLASS(VARIABLE_4RD), TARGET :: SELF

    IF (SELF%LT9) SELF%FPH9%PTR => SELF%FT9%PTR
  END SUBROUTINE VARIABLE_4RD_PH9TOT9



  SUBROUTINE VARIABLE_2RB_FINAL(SELF)
    ! Templated destructor that cleans up an object instance
    CLASS(VARIABLE_2RB) :: SELF

    IF (ASSOCIATED(SELF%FT0)) THEN
      CALL SELF%FT0%FINAL()
      DEALLOCATE(SELF%FT0)
    END IF
    IF (ASSOCIATED(SELF%FT1)) THEN
      CALL SELF%FT1%FINAL()
      DEALLOCATE(SELF%FT1)
    END IF
    IF (ASSOCIATED(SELF%FT9)) THEN
      CALL SELF%FT9%FINAL()
      DEALLOCATE(SELF%FT9)
    END IF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      CALL SELF%FPH9%FINAL()
      DEALLOCATE(SELF%FPH9)
    END IF
    IF (ASSOCIATED(SELF%FDL)) THEN
      CALL SELF%FDL%FINAL()
      DEALLOCATE(SELF%FDL)
    END IF
    IF (ASSOCIATED(SELF%FDM)) THEN
      CALL SELF%FDM%FINAL()
      DEALLOCATE(SELF%FDM)
    END IF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      CALL SELF%FDL9%FINAL()
      DEALLOCATE(SELF%FDL9)
    END IF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      CALL SELF%FDM9%FINAL()
      DEALLOCATE(SELF%FDM9)
    END IF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      CALL SELF%FPC_PH%FINAL()
      DEALLOCATE(SELF%FPC_PH)
    END IF
  END SUBROUTINE VARIABLE_2RB_FINAL

  SUBROUTINE VARIABLE_3RB_FINAL(SELF)
    ! Templated destructor that cleans up an object instance
    CLASS(VARIABLE_3RB) :: SELF

    IF (ASSOCIATED(SELF%FT0)) THEN
      CALL SELF%FT0%FINAL()
      DEALLOCATE(SELF%FT0)
    END IF
    IF (ASSOCIATED(SELF%FT1)) THEN
      CALL SELF%FT1%FINAL()
      DEALLOCATE(SELF%FT1)
    END IF
    IF (ASSOCIATED(SELF%FT9)) THEN
      CALL SELF%FT9%FINAL()
      DEALLOCATE(SELF%FT9)
    END IF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      CALL SELF%FPH9%FINAL()
      DEALLOCATE(SELF%FPH9)
    END IF
    IF (ASSOCIATED(SELF%FDL)) THEN
      CALL SELF%FDL%FINAL()
      DEALLOCATE(SELF%FDL)
    END IF
    IF (ASSOCIATED(SELF%FDM)) THEN
      CALL SELF%FDM%FINAL()
      DEALLOCATE(SELF%FDM)
    END IF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      CALL SELF%FDL9%FINAL()
      DEALLOCATE(SELF%FDL9)
    END IF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      CALL SELF%FDM9%FINAL()
      DEALLOCATE(SELF%FDM9)
    END IF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      CALL SELF%FPC_PH%FINAL()
      DEALLOCATE(SELF%FPC_PH)
    END IF
  END SUBROUTINE VARIABLE_3RB_FINAL

  SUBROUTINE VARIABLE_4RB_FINAL(SELF)
    ! Templated destructor that cleans up an object instance
    CLASS(VARIABLE_4RB) :: SELF

    IF (ASSOCIATED(SELF%FT0)) THEN
      CALL SELF%FT0%FINAL()
      DEALLOCATE(SELF%FT0)
    END IF
    IF (ASSOCIATED(SELF%FT1)) THEN
      CALL SELF%FT1%FINAL()
      DEALLOCATE(SELF%FT1)
    END IF
    IF (ASSOCIATED(SELF%FT9)) THEN
      CALL SELF%FT9%FINAL()
      DEALLOCATE(SELF%FT9)
    END IF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      CALL SELF%FPH9%FINAL()
      DEALLOCATE(SELF%FPH9)
    END IF
    IF (ASSOCIATED(SELF%FDL)) THEN
      CALL SELF%FDL%FINAL()
      DEALLOCATE(SELF%FDL)
    END IF
    IF (ASSOCIATED(SELF%FDM)) THEN
      CALL SELF%FDM%FINAL()
      DEALLOCATE(SELF%FDM)
    END IF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      CALL SELF%FDL9%FINAL()
      DEALLOCATE(SELF%FDL9)
    END IF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      CALL SELF%FDM9%FINAL()
      DEALLOCATE(SELF%FDM9)
    END IF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      CALL SELF%FPC_PH%FINAL()
      DEALLOCATE(SELF%FPC_PH)
    END IF
  END SUBROUTINE VARIABLE_4RB_FINAL

  SUBROUTINE VARIABLE_2RD_FINAL(SELF)
    ! Templated destructor that cleans up an object instance
    CLASS(VARIABLE_2RD) :: SELF

    IF (ASSOCIATED(SELF%FT0)) THEN
      CALL SELF%FT0%FINAL()
      DEALLOCATE(SELF%FT0)
    END IF
    IF (ASSOCIATED(SELF%FT1)) THEN
      CALL SELF%FT1%FINAL()
      DEALLOCATE(SELF%FT1)
    END IF
    IF (ASSOCIATED(SELF%FT9)) THEN
      CALL SELF%FT9%FINAL()
      DEALLOCATE(SELF%FT9)
    END IF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      CALL SELF%FPH9%FINAL()
      DEALLOCATE(SELF%FPH9)
    END IF
    IF (ASSOCIATED(SELF%FDL)) THEN
      CALL SELF%FDL%FINAL()
      DEALLOCATE(SELF%FDL)
    END IF
    IF (ASSOCIATED(SELF%FDM)) THEN
      CALL SELF%FDM%FINAL()
      DEALLOCATE(SELF%FDM)
    END IF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      CALL SELF%FDL9%FINAL()
      DEALLOCATE(SELF%FDL9)
    END IF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      CALL SELF%FDM9%FINAL()
      DEALLOCATE(SELF%FDM9)
    END IF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      CALL SELF%FPC_PH%FINAL()
      DEALLOCATE(SELF%FPC_PH)
    END IF
  END SUBROUTINE VARIABLE_2RD_FINAL

  SUBROUTINE VARIABLE_3RD_FINAL(SELF)
    ! Templated destructor that cleans up an object instance
    CLASS(VARIABLE_3RD) :: SELF

    IF (ASSOCIATED(SELF%FT0)) THEN
      CALL SELF%FT0%FINAL()
      DEALLOCATE(SELF%FT0)
    END IF
    IF (ASSOCIATED(SELF%FT1)) THEN
      CALL SELF%FT1%FINAL()
      DEALLOCATE(SELF%FT1)
    END IF
    IF (ASSOCIATED(SELF%FT9)) THEN
      CALL SELF%FT9%FINAL()
      DEALLOCATE(SELF%FT9)
    END IF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      CALL SELF%FPH9%FINAL()
      DEALLOCATE(SELF%FPH9)
    END IF
    IF (ASSOCIATED(SELF%FDL)) THEN
      CALL SELF%FDL%FINAL()
      DEALLOCATE(SELF%FDL)
    END IF
    IF (ASSOCIATED(SELF%FDM)) THEN
      CALL SELF%FDM%FINAL()
      DEALLOCATE(SELF%FDM)
    END IF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      CALL SELF%FDL9%FINAL()
      DEALLOCATE(SELF%FDL9)
    END IF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      CALL SELF%FDM9%FINAL()
      DEALLOCATE(SELF%FDM9)
    END IF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      CALL SELF%FPC_PH%FINAL()
      DEALLOCATE(SELF%FPC_PH)
    END IF
  END SUBROUTINE VARIABLE_3RD_FINAL

  SUBROUTINE VARIABLE_4RD_FINAL(SELF)
    ! Templated destructor that cleans up an object instance
    CLASS(VARIABLE_4RD) :: SELF

    IF (ASSOCIATED(SELF%FT0)) THEN
      CALL SELF%FT0%FINAL()
      DEALLOCATE(SELF%FT0)
    END IF
    IF (ASSOCIATED(SELF%FT1)) THEN
      CALL SELF%FT1%FINAL()
      DEALLOCATE(SELF%FT1)
    END IF
    IF (ASSOCIATED(SELF%FT9)) THEN
      CALL SELF%FT9%FINAL()
      DEALLOCATE(SELF%FT9)
    END IF
    IF (ASSOCIATED(SELF%FPH9)) THEN
      CALL SELF%FPH9%FINAL()
      DEALLOCATE(SELF%FPH9)
    END IF
    IF (ASSOCIATED(SELF%FDL)) THEN
      CALL SELF%FDL%FINAL()
      DEALLOCATE(SELF%FDL)
    END IF
    IF (ASSOCIATED(SELF%FDM)) THEN
      CALL SELF%FDM%FINAL()
      DEALLOCATE(SELF%FDM)
    END IF
    IF (ASSOCIATED(SELF%FDL9)) THEN
      CALL SELF%FDL9%FINAL()
      DEALLOCATE(SELF%FDL9)
    END IF
    IF (ASSOCIATED(SELF%FDM9)) THEN
      CALL SELF%FDM9%FINAL()
      DEALLOCATE(SELF%FDM9)
    END IF
    IF (ASSOCIATED(SELF%FPC_PH)) THEN
      CALL SELF%FPC_PH%FINAL()
      DEALLOCATE(SELF%FPC_PH)
    END IF
  END SUBROUTINE VARIABLE_4RD_FINAL


END MODULE VARIABLE_MODULE
