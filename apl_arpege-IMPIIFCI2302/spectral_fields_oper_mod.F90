MODULE SPECTRAL_FIELDS_OPER_MOD

!   Purpose.
!   --------
!     This module contains the basic operators associated
!     to the SPECTRAL_FIELD type.
!
!   Author.
!   -------
!     Yannick Tremolet
!
!   Modifications.
!   --------------
!     Original    22-Jul-2004 Created from SPECTRAL_FIELDS_MOD.
!     C. Fischer  20-May-2005 Updated for Aladin
!     M. Chrust   3-Jan-2020 Implement SELF_AXPY
! ------------------------------------------------------------------

USE PARKIND1, ONLY : JPIM, JPRB
USE YOMHOOK , ONLY : LHOOK, DR_HOOK, JPHOOK
USE SPECTRAL_FIELDS_DATA, ONLY: SPECTRAL_FIELD, LELAM

IMPLICIT NONE
PRIVATE
PUBLIC ASSIGNMENT(=), OPERATOR(.EQV.), OPERATOR(.NEQV.), &
     & SELF_ADD, SELF_SUB, SELF_MUL, SELF_AXPY
PRIVATE INDXFIND

! ------------------------------------------------------------------

INTERFACE ASSIGNMENT (=)
MODULE PROCEDURE ASSIGN_SP_SP, ASSIGN_SCALAR_SP, ASSIGN_AR_SP, ASSIGN_SP_AR
END INTERFACE

INTERFACE OPERATOR (.EQV.)
MODULE PROCEDURE EQUIV_SPEC
END INTERFACE

INTERFACE OPERATOR (.NEQV.)
MODULE PROCEDURE NEQUIV_SPEC
END INTERFACE

INTERFACE SELF_ADD  ! What we really want here is ASSIGNMENT (+=)
MODULE PROCEDURE SELF_ADD_SP
END INTERFACE

INTERFACE SELF_SUB  ! What we really want here is ASSIGNMENT (-=)
MODULE PROCEDURE SELF_SUB_SP
END INTERFACE

INTERFACE SELF_MUL  ! What we really want here is ASSIGNMENT (*=)
MODULE PROCEDURE SELF_MUL_SP, SELF_MUL_SCAL
END INTERFACE

INTERFACE SELF_AXPY
MODULE PROCEDURE SELF_AXPY_SP
END INTERFACE

! ------------------------------------------------------------------
CONTAINS
! ------------------------------------------------------------------

SUBROUTINE ASSIGN_SCALAR_SP(YDSP,PVAL)
TYPE (SPECTRAL_FIELD), INTENT(INOUT) :: YDSP
REAL(KIND=JPRB), INTENT(IN) :: PVAL

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:ASSIGN_SCALAR_SP',0,ZHOOK_HANDLE)
YDSP%SP2D(:,:)  =PVAL
YDSP%SP3D(:,:,:)=PVAL
IF (LELAM) YDSP%SP1D(:,:)  =PVAL

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:ASSIGN_SCALAR_SP',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_SCALAR_SP

! ------------------------------------------------------------------

SUBROUTINE ASSIGN_SP_SP(YDSP1,YDSP2)
TYPE (SPECTRAL_FIELD), INTENT(INOUT) :: YDSP1
TYPE (SPECTRAL_FIELD), INTENT(IN)    :: YDSP2
INTEGER(KIND=JPIM) :: JF,JM,IM,ILEN,JS1,JS2,JF2

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:ASSIGN_SP_SP',0,ZHOOK_HANDLE)

IF ((YDSP1%NSMAX<=YDSP2%NSMAX).AND.(.NOT.LELAM)) THEN      ! Truncate in IFS
  DO JF=1,YDSP1%NS2D
    JF2=INDXFIND(YDSP2%NGRIB2,YDSP1%NGRIB2(JF))
    IF (JF2>0) THEN
      DO JM=1,YDSP1%NUMP
        IM=YDSP1%MYMS(JM)
        ILEN=2*(YDSP1%NSMAX-IM+1)-1
        JS1=YDSP1%NASM0(IM)
        JS2=YDSP2%NASM0(IM)
          YDSP1%SP2D(JS1:JS1+ILEN,JF) = YDSP2%SP2D(JS2:JS2+ILEN,JF2)
      ENDDO
    ELSE
      YDSP1%SP2D(:,JF) = 0.0_JPRB
    ENDIF
  ENDDO
  DO JF=1,YDSP1%NS3D
    JF2=INDXFIND(YDSP2%NGRIB3,YDSP1%NGRIB3(JF))
    IF (JF2>0) THEN
      DO JM=1,YDSP1%NUMP
        IM=YDSP1%MYMS(JM)
        ILEN=2*(YDSP1%NSMAX-IM+1)-1
        JS1=YDSP1%NASM0(IM)
        JS2=YDSP2%NASM0(IM)
          YDSP1%SP3D(:,JS1:JS1+ILEN,JF) = YDSP2%SP3D(:,JS2:JS2+ILEN,JF2)
      ENDDO
    ELSE
      YDSP1%SP3D(:,:,JF) = 0.0_JPRB
    ENDIF
  ENDDO
ELSEIF ((YDSP1%NSMAX>YDSP2%NSMAX).AND.(.NOT.LELAM)) THEN  ! Pad with zeros in IFS
  YDSP1%SP2D(:,:) = 0.0_JPRB
  DO JF=1,YDSP2%NS2D
    JF2=INDXFIND(YDSP2%NGRIB2,YDSP1%NGRIB2(JF))
    IF (JF2>0) THEN
      DO JM=1,YDSP2%NUMP
        IM=YDSP1%MYMS(JM)
        ILEN=2*(YDSP2%NSMAX-IM+1)-1
        JS1=YDSP1%NASM0(IM)
        JS2=YDSP2%NASM0(IM)
          YDSP1%SP2D(JS1:JS1+ILEN,JF) = YDSP2%SP2D(JS2:JS2+ILEN,JF2)
      ENDDO
    ENDIF
  ENDDO
  YDSP1%SP3D(:,:,:) = 0.0_JPRB
  DO JF=1,YDSP2%NS3D
    JF2=INDXFIND(YDSP2%NGRIB3,YDSP1%NGRIB3(JF))
    IF (JF2>0) THEN
      DO JM=1,YDSP2%NUMP
        IM=YDSP1%MYMS(JM)
        ILEN=2*(YDSP2%NSMAX-IM+1)-1
        JS1=YDSP1%NASM0(IM)
        JS2=YDSP2%NASM0(IM)
          YDSP1%SP3D(:,JS1:JS1+ILEN,JF) = YDSP2%SP3D(:,JS2:JS2+ILEN,JF2)
      ENDDO
    ENDIF
  ENDDO
ELSEIF ((((YDSP1%NSMAX<YDSP2%NSMAX).AND.(YDSP1%NMSMAX<=YDSP2%NMSMAX)).OR. &
 &((YDSP1%NSMAX<=YDSP2%NSMAX).AND.(YDSP1%NMSMAX<YDSP2%NMSMAX))) &
 &.AND.(LELAM)) THEN      ! Truncate in Aladin
  DO JF=1,YDSP1%NS2D
    JF2=INDXFIND(YDSP2%NGRIB2,YDSP1%NGRIB2(JF))
    IF (JF2>0) THEN
      DO JM=1,YDSP1%NUMP
        IM=YDSP1%MYMS(JM)
        ILEN=YDSP1%NCPL4M(IM)-1
        JS1=YDSP1%NESM0(IM)
        JS2=YDSP2%NESM0(IM)
          YDSP1%SP2D(JS1:JS1+ILEN,JF) = YDSP2%SP2D(JS2:JS2+ILEN,JF2)
      ENDDO
    ELSE
      YDSP1%SP2D(:,JF) = 0.0_JPRB
    ENDIF
  ENDDO
  DO JF=1,YDSP1%NS3D
    JF2=INDXFIND(YDSP2%NGRIB3,YDSP1%NGRIB3(JF))
    IF (JF2>0) THEN
      DO JM=1,YDSP1%NUMP
        IM=YDSP1%MYMS(JM)
        ILEN=YDSP1%NCPL4M(IM)-1
        JS1=YDSP1%NESM0(IM)
        JS2=YDSP2%NESM0(IM)
          YDSP1%SP3D(:,JS1:JS1+ILEN,JF) = YDSP2%SP3D(:,JS2:JS2+ILEN,JF2)
      ENDDO
    ELSE
      YDSP1%SP3D(:,:,JF) = 0.0_JPRB
    ENDIF
  ENDDO
ELSEIF ((((YDSP1%NSMAX>YDSP2%NSMAX).AND.(YDSP1%NMSMAX>=YDSP2%NMSMAX)).OR. &
 &((YDSP1%NSMAX>=YDSP2%NSMAX).AND.(YDSP1%NMSMAX>YDSP2%NMSMAX))) &
 &.AND.(LELAM)) THEN  ! Pad with zeros in Aladin
  YDSP1%SP2D(:,:) = 0.0_JPRB
  DO JF=1,YDSP2%NS2D
    JF2=INDXFIND(YDSP2%NGRIB2,YDSP1%NGRIB2(JF))
    IF (JF2>0) THEN
      DO JM=1,YDSP2%NUMP
        IM=YDSP2%MYMS(JM)
        ILEN=YDSP2%NCPL4M(IM)-1
        JS1=YDSP1%NESM0(IM)
        JS2=YDSP2%NESM0(IM)
          YDSP1%SP2D(JS1:JS1+ILEN,JF) = YDSP2%SP2D(JS2:JS2+ILEN,JF2)
      ENDDO
    ENDIF
  ENDDO
  YDSP1%SP3D(:,:,:) = 0.0_JPRB
  DO JF=1,YDSP2%NS3D
    JF2=INDXFIND(YDSP2%NGRIB3,YDSP1%NGRIB3(JF))
    IF (JF2>0) THEN
      DO JM=1,YDSP2%NUMP
        IM=YDSP2%MYMS(JM)
        ILEN=YDSP2%NCPL4M(IM)-1
        JS1=YDSP1%NESM0(IM)
        JS2=YDSP2%NESM0(IM)
          YDSP1%SP3D(:,JS1:JS1+ILEN,JF) = YDSP2%SP3D(:,JS2:JS2+ILEN,JF2)
      ENDDO
    ENDIF
  ENDDO
ELSEIF (((YDSP1%NSMAX/=YDSP2%NSMAX).OR.(YDSP1%NMSMAX/=YDSP2%NMSMAX)).AND. &
 & (LELAM)) THEN  ! Unfeasible cases left in Aladin
  CALL ABOR1('ASSIGN_SP_SP error: mismatch in Aladin spectral truncations')
ELSE                                   ! Copy
  DO JF=1,YDSP2%NS2D
    JF2=INDXFIND(YDSP2%NGRIB2,YDSP1%NGRIB2(JF))
    IF (JF2>0) THEN
      YDSP1%SP2D(:,JF) = YDSP2%SP2D(:,JF2)
    ELSE
      YDSP1%SP2D(:,JF) = 0.0_JPRB
    ENDIF
  ENDDO
  DO JF=1,YDSP2%NS3D
    JF2=INDXFIND(YDSP2%NGRIB3,YDSP1%NGRIB3(JF))
    IF (JF2>0) THEN
      YDSP1%SP3D(:,:,JF) = YDSP2%SP3D(:,:,JF2)
    ELSE
      YDSP1%SP3D(:,:,JF) = 0.0_JPRB
    ENDIF
  ENDDO
ENDIF

! mean wind always copied if present in input
DO JF=1,YDSP2%NS1D
  YDSP1%SP1D(:,JF)=YDSP2%SP1D(:,JF)
ENDDO

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:ASSIGN_SP_SP',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_SP_SP

! ------------------------------------------------------------------

SUBROUTINE ASSIGN_AR_SP(YDSP,PFLAT)
USE YOMLUN, ONLY : NULOUT
TYPE (SPECTRAL_FIELD), INTENT(INOUT) :: YDSP
REAL(KIND=JPRB), INTENT(IN) :: PFLAT(:)
INTEGER(KIND=JPIM) :: I2D,I3D,ISHAPE2D(2),ISHAPE3D(3)
INTEGER(KIND=JPIM) :: II,IM,IOFF,IL,JSG,JF,JM,JS,JN,JIR,JL,ILEN

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:ASSIGN_AR_SP',0,ZHOOK_HANDLE)
IF (SIZE(PFLAT)==YDSP%NSPSIZEL) THEN             ! local array (IFS and Aladin)

  I2D=YDSP%NS2D*YDSP%NSPEC2
  I3D=YDSP%NFLEVL*YDSP%NS3D*YDSP%NSPEC2
  ISHAPE2D(1)=YDSP%NSPEC2
  ISHAPE2D(2)=YDSP%NS2D
  ISHAPE3D(1)=YDSP%NFLEVL
  ISHAPE3D(2)=YDSP%NSPEC2
  ISHAPE3D(3)=YDSP%NS3D
  YDSP%SP2D(:,:)  =RESHAPE(PFLAT(    1:    I2D),ISHAPE2D)
  YDSP%SP3D(:,:,:)=RESHAPE(PFLAT(I2D+1:I2D+I3D),ISHAPE3D)

ELSEIF ((SIZE(PFLAT)==YDSP%NSPSIZEG).AND.(.NOT.LELAM)) THEN         ! global array in IFS

  IOFF=0
  DO JF=1,YDSP%NS2D
    DO JM=1,YDSP%NUMP
      IM=YDSP%MYMS(JM)
      JSG=YDSP%NASM0G(IM)-1
      JS =YDSP%NASM0 (IM)-1
      ILEN=2*(YDSP%NSMAX-IM+1)
      YDSP%SP2D(JS+1:JS+ILEN,JF)=PFLAT(IOFF+JSG+1:IOFF+JSG+ILEN)
    ENDDO
    IOFF=IOFF+YDSP%NSPEC2G
  ENDDO
  IOFF=YDSP%NS2G*YDSP%NSPEC2G
  DO JF=1,YDSP%NS3D
    DO JM=1,YDSP%NUMP
      IM=YDSP%MYMS(JM)
      DO JN=IM,YDSP%NSMAX
        DO JIR=0,1
          JSG=YDSP%NASM0G(IM)+(JN-IM)*2+JIR
          JS =YDSP%NASM0 (IM)+(JN-IM)*2+JIR
          II=IOFF+(JSG-1)*YDSP%NFLEVG
          DO JL=1,YDSP%NFLEVL
            IL=YDSP%MYLEVS(JL)
            YDSP%SP3D(JL,JS,JF)=PFLAT(II+IL)
          ENDDO
        ENDDO
      ENDDO
    ENDDO
    IOFF=IOFF+YDSP%NSPEC2G*YDSP%NFLEVG
  ENDDO

ELSEIF ((SIZE(PFLAT)==YDSP%NSPSIZEG).AND.(LELAM)) THEN         ! global array in Aladin

  IOFF=0
  DO JF=1,YDSP%NS2D
    DO JM=1,YDSP%NUMP
      IM=YDSP%MYMS(JM)
      JSG=YDSP%NESM0G(IM)-1
      JS =YDSP%NESM0 (IM)-1
      ILEN=YDSP%NCPL4M(IM)
      YDSP%SP2D(JS+1:JS+ILEN,JF)=PFLAT(IOFF+JSG+1:IOFF+JSG+ILEN)
    ENDDO
    IOFF=IOFF+YDSP%NSPEC2G
  ENDDO
  IOFF=YDSP%NS2G*YDSP%NSPEC2G
  DO JF=1,YDSP%NS3D
    DO JM=1,YDSP%NUMP
      IM=YDSP%MYMS(JM)
      DO JN=1,YDSP%NCPL4M(IM)
        JSG=YDSP%NESM0G(IM)+JN-1
        JS =YDSP%NESM0 (IM)+JN-1
        II=IOFF+(JSG-1)*YDSP%NFLEVG
        DO JL=1,YDSP%NFLEVL
          IL=YDSP%MYLEVS(JL)
          YDSP%SP3D(JL,JS,JF)=PFLAT(II+IL)
        ENDDO
      ENDDO
    ENDDO
    IOFF=IOFF+YDSP%NSPEC2G*YDSP%NFLEVG
  ENDDO

ELSE
  CALL ABOR1('assign_ar_sp: cannot assign array to spectral field')
ENDIF

!cf mean wind must be copied apart, but for conversions from spectral_field
!cf to control_vector and back, 0. seems to be the most appropriate value

IF (LELAM) YDSP%SP1D(:,:)=0.0_JPRB

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:ASSIGN_AR_SP',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_AR_SP

! ------------------------------------------------------------------

SUBROUTINE ASSIGN_SP_AR(PFLAT,YDSP)
REAL(KIND=JPRB), INTENT(OUT) :: PFLAT(:)
TYPE (SPECTRAL_FIELD), INTENT(IN) :: YDSP
INTEGER(KIND=JPIM) :: I2D,I3D,ISHAPE2D(1),ISHAPE3D(1)

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:ASSIGN_SP_AR',0,ZHOOK_HANDLE)
IF (SIZE(PFLAT)==YDSP%NSPSIZEL) THEN         ! local array (IFS and Aladin)

  I2D=YDSP%NS2D*YDSP%NSPEC2
  I3D=YDSP%NFLEVL*YDSP%NS3D*YDSP%NSPEC2
  ISHAPE2D(1)=I2D
  ISHAPE3D(1)=I3D
  PFLAT(    1:    I2D)=RESHAPE(YDSP%SP2D(:,:)  ,ISHAPE2D)
  PFLAT(I2D+1:I2D+I3D)=RESHAPE(YDSP%SP3D(:,:,:),ISHAPE3D)

ELSEIF (SIZE(PFLAT)==YDSP%NSPSIZEG) THEN     ! global array
  CALL ABOR1('Cannot assign spectral field to global array. '// &
           & 'Please use ALLGATHER_SPEC')
ELSE
  CALL ABOR1('Vector wrong length')
ENDIF

!cf information from ydsp%sp1d is not retrieved here - external copy required

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:ASSIGN_SP_AR',1,ZHOOK_HANDLE)
END SUBROUTINE ASSIGN_SP_AR

! ------------------------------------------------------------------

LOGICAL FUNCTION EQUIV_SPEC(YDSP1,YDSP2)
TYPE(SPECTRAL_FIELD), INTENT(IN) :: YDSP1
TYPE(SPECTRAL_FIELD), INTENT(IN) :: YDSP2
LOGICAL :: LL
INTEGER(KIND=JPIM) :: JF

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:EQUIV_SPEC',0,ZHOOK_HANDLE)
LL = .TRUE.
LL = LL .AND. (YDSP1%NS2G ==YDSP2%NS2G)
LL = LL .AND. (YDSP1%NS3D ==YDSP2%NS3D)
LL = LL .AND. (YDSP1%NS1D ==YDSP2%NS1D)
IF (LL) THEN
  DO JF=1,YDSP1%NS2G+YDSP1%NS3D
    LL = LL .AND. (YDSP1%NGRIB(JF)==YDSP2%NGRIB(JF))
  ENDDO
ENDIF

EQUIV_SPEC=LL

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:EQUIV_SPEC',1,ZHOOK_HANDLE)
END FUNCTION EQUIV_SPEC

! ------------------------------------------------------------------

LOGICAL FUNCTION NEQUIV_SPEC(YDSP1,YDSP2)
TYPE(SPECTRAL_FIELD), INTENT(IN) :: YDSP1
TYPE(SPECTRAL_FIELD), INTENT(IN) :: YDSP2

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:NEQUIV_SPEC',0,ZHOOK_HANDLE)
NEQUIV_SPEC = .NOT. EQUIV_SPEC(YDSP1,YDSP2)

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:NEQUIV_SPEC',1,ZHOOK_HANDLE)
END FUNCTION NEQUIV_SPEC

! ------------------------------------------------------------------

SUBROUTINE SELF_ADD_SP(YDA,YDB)
TYPE(SPECTRAL_FIELD), INTENT(INOUT) :: YDA
TYPE(SPECTRAL_FIELD), INTENT(IN)    :: YDB
INTEGER(KIND=JPIM) :: JS,JL,JF

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_ADD_SP',0,ZHOOK_HANDLE)
IF (YDA.NEQV.YDB) CALL ABOR1('Incompatible spectral fields')
IF (YDA%NSMAX/=YDB%NSMAX) CALL ABOR1('Incompatible spectral resolutions')
IF ((YDA%NMSMAX/=YDB%NMSMAX).AND.LELAM) CALL ABOR1('Incompatible spectral resolutions LAM')

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js)
DO JF=1,YDA%NS2D
  DO JS=1,YDA%NSPEC2
    YDA%SP2D(JS,JF) = YDA%SP2D(JS,JF) + YDB%SP2D(JS,JF)
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js,jl)
DO JF=1,YDA%NS3D
  DO JS=1,YDA%NSPEC2
    DO JL=1,YDA%NFLEVL
      YDA%SP3D(JL,JS,JF) = YDA%SP3D(JL,JS,JF) + YDB%SP3D(JL,JS,JF)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LELAM) THEN
  DO JF=1,YDA%NS1D
    DO JL=1,YDA%NFLEVL
      YDA%SP1D(JL,JF) = YDA%SP1D(JL,JF) + YDB%SP1D(JL,JF)
    ENDDO
  ENDDO
ENDIF

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_ADD_SP',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_ADD_SP
! ------------------------------------------------------------------

SUBROUTINE SELF_AXPY_SP(YDA,YDB,PZ)
TYPE(SPECTRAL_FIELD), INTENT(INOUT) :: YDA
TYPE(SPECTRAL_FIELD), INTENT(IN)    :: YDB
REAL(KIND=JPRB),      INTENT(IN)    :: PZ
INTEGER(KIND=JPIM) :: JS,JL,JF

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_AXPY_SP',0,ZHOOK_HANDLE)
IF (YDA.NEQV.YDB) CALL ABOR1('Incompatible spectral fields')
IF (YDA%NSMAX/=YDB%NSMAX) CALL ABOR1('Incompatible spectral resolutions')
IF ((YDA%NMSMAX/=YDB%NMSMAX).AND.LELAM) CALL ABOR1('Incompatible spectral resolutions LAM')

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js)
DO JF=1,YDA%NS2D
  DO JS=1,YDA%NSPEC2
    YDA%SP2D(JS,JF) = YDA%SP2D(JS,JF) + PZ * YDB%SP2D(JS,JF)
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js,jl)
DO JF=1,YDA%NS3D
  DO JS=1,YDA%NSPEC2
    DO JL=1,YDA%NFLEVL
      YDA%SP3D(JL,JS,JF) = YDA%SP3D(JL,JS,JF) + PZ * YDB%SP3D(JL,JS,JF)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LELAM) THEN
  DO JF=1,YDA%NS1D
    DO JL=1,YDA%NFLEVL
      YDA%SP1D(JL,JF) = YDA%SP1D(JL,JF) + PZ * YDB%SP1D(JL,JF)
    ENDDO
  ENDDO
ENDIF

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_AXPY_SP',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_AXPY_SP
! ------------------------------------------------------------------

SUBROUTINE SELF_SUB_SP(YDA,YDB)
TYPE(SPECTRAL_FIELD), INTENT(INOUT) :: YDA
TYPE(SPECTRAL_FIELD), INTENT(IN)    :: YDB
INTEGER(KIND=JPIM) :: JS,JL,JF

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_SUB_SP',0,ZHOOK_HANDLE)
IF (YDA.NEQV.YDB) CALL ABOR1('Incompatible spectral fields')
IF (YDA%NSMAX/=YDB%NSMAX) CALL ABOR1('Incompatible spectral resolutions')
IF ((YDA%NMSMAX/=YDB%NMSMAX).AND.LELAM) CALL ABOR1('Incompatible spectral resolutions LAM')

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js)
DO JF=1,YDA%NS2D
  DO JS=1,YDA%NSPEC2
    YDA%SP2D(JS,JF) = YDA%SP2D(JS,JF) - YDB%SP2D(JS,JF)
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js,jl)
DO JF=1,YDA%NS3D
  DO JS=1,YDA%NSPEC2
    DO JL=1,YDA%NFLEVL
      YDA%SP3D(JL,JS,JF) = YDA%SP3D(JL,JS,JF) - YDB%SP3D(JL,JS,JF)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LELAM) THEN
  DO JF=1,YDA%NS1D
    DO JL=1,YDA%NFLEVL
      YDA%SP1D(JL,JF) = YDA%SP1D(JL,JF) - YDB%SP1D(JL,JF)
    ENDDO
  ENDDO
ENDIF

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_SUB_SP',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_SUB_SP
! ------------------------------------------------------------------

SUBROUTINE SELF_MUL_SP(YDA,YDB)
TYPE(SPECTRAL_FIELD), INTENT(INOUT) :: YDA
TYPE(SPECTRAL_FIELD), INTENT(IN)    :: YDB
INTEGER(KIND=JPIM) :: JS,JL,JF

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_MUL_SP',0,ZHOOK_HANDLE)
IF (YDA.NEQV.YDB) CALL ABOR1('Incompatible spectral fields')
IF (YDA%NSMAX/=YDB%NSMAX) CALL ABOR1('Incompatible spectral resolutions')
IF ((YDA%NMSMAX/=YDB%NMSMAX).AND.LELAM) CALL ABOR1('Incompatible spectral resolutions LAM')

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js)
DO JF=1,YDA%NS2D
  DO JS=1,YDA%NSPEC2
    YDA%SP2D(JS,JF) = YDA%SP2D(JS,JF) * YDB%SP2D(JS,JF)
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js,jl)
DO JF=1,YDA%NS3D
  DO JS=1,YDA%NSPEC2
    DO JL=1,YDA%NFLEVL
      YDA%SP3D(JL,JS,JF) = YDA%SP3D(JL,JS,JF) * YDB%SP3D(JL,JS,JF)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LELAM) THEN
  DO JF=1,YDA%NS1D
    DO JL=1,YDA%NFLEVL
      YDA%SP1D(JL,JF) = YDA%SP1D(JL,JF) * YDB%SP1D(JL,JF)
    ENDDO
  ENDDO
ENDIF

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_MUL_SP',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_MUL_SP
! ------------------------------------------------------------------

SUBROUTINE SELF_MUL_SCAL(YDA,PB)
TYPE(SPECTRAL_FIELD), INTENT(INOUT) :: YDA
REAL(KIND=JPRB),      INTENT(IN)    :: PB
INTEGER(KIND=JPIM) :: JS,JL,JF

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js)
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_MUL_SCAL',0,ZHOOK_HANDLE)
DO JF=1,YDA%NS2D
  DO JS=1,YDA%NSPEC2
    YDA%SP2D(JS,JF) = PB * YDA%SP2D(JS,JF)
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

!yt!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(jf,js,jl)
DO JF=1,YDA%NS3D
  DO JS=1,YDA%NSPEC2
    DO JL=1,YDA%NFLEVL
      YDA%SP3D(JL,JS,JF) = PB * YDA%SP3D(JL,JS,JF)
    ENDDO
  ENDDO
ENDDO
!yt!$OMP END PARALLEL DO

IF (LELAM) THEN
  DO JF=1,YDA%NS1D
    DO JL=1,YDA%NFLEVL
      YDA%SP1D(JL,JF) = PB * YDA%SP1D(JL,JF)
    ENDDO
  ENDDO
ENDIF

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:SELF_MUL_SCAL',1,ZHOOK_HANDLE)
END SUBROUTINE SELF_MUL_SCAL

! ------------------------------------------------------------------

FUNCTION INDXFIND(KARRAY,KVAL)

INTEGER(KIND=JPIM) :: INDXFIND
INTEGER(KIND=JPIM), INTENT(IN) :: KARRAY(:), KVAL
INTEGER(KIND=JPIM) :: II, JJ
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:INDXFIND',0,ZHOOK_HANDLE)
JJ=0
II=1
DO WHILE (II<=SIZE(KARRAY) .AND. JJ==0)
  IF (KARRAY(II)==KVAL) JJ=II
  II=II+1
ENDDO
INDXFIND=JJ
IF (LHOOK) CALL DR_HOOK('SPECTRAL_FIELDS_OPER_MOD:INDXFIND',1,ZHOOK_HANDLE)
END FUNCTION INDXFIND

! ------------------------------------------------------------------

END MODULE SPECTRAL_FIELDS_OPER_MOD
