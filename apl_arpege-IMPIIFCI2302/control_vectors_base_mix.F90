MODULE CONTROL_VECTORS_BASE_MIX

!   Purpose.
!   --------
!     This module contains the definition of the CONTROL_VECTOR type
!     and basic routines (allocate, deallocate).
!
!   Author.
!   -------
!     Y. Tremolet
!
!   Modifications.
!   -------------- 
!     Original   25-Jul-2004 Split from CONTROL_VECTORS
!     A. Deckmyn 01-Oct-2008 LAM-wavelet Jb
!     M. Fisher  15-Feb-2013 Put globals into structures. Introduce JB_CONTROL_VECTORS
!     Y. Michel, MF, June 2018 Extension of the control variable for sqrt EnVar
!     S. Massart 19-Feb-2019 Parameter optimisation
!     Y. Michel, MF, May 2019 Move LWAVELETJB TO INITCV
! ------------------------------------------------------------------

USE PARKIND1, ONLY : JPIM, JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK, JPHOOK
USE SPECTRAL_FIELDS_MOD, ONLY: SPECTRAL_FIELD, INQ_SPEC, DEALLOCATE_SPEC
USE CONTROL_VECTORS_DATA_MIX, ONLY: CONTROL_VECTOR_DATA_STRUCT
USE JB_CONTROL_VECTORS_BASE_MOD, ONLY: JB_CONTROL_VECTOR,&
                                & ALLOCATE_JB_CTLVEC_NODATA,&
                                & DEALLOCATE_JB_CTLVEC_NODATA

IMPLICIT NONE
PRIVATE
PUBLIC CONTROL_VECTOR, ALLOCATE_CTLVEC, DEALLOCATE_CTLVEC,&
     & OPERATOR (.EQV.), OPERATOR (.NEQV.), CHECK

! ------------------------------------------------------------------

TYPE CONTROL_VECTOR
  LOGICAL :: LINITCV, LTOVSCV, LAM1D, LELAM, LENSCV 
  REAL(KIND=JPRB), POINTER :: DATA(:) => NULL()
  INTEGER(KIND=JPIM) :: NSMAX, NMSMAX, NMODERR, NSERR, NPARA, NPECV
  INTEGER(KIND=JPIM) :: NSMAX_ENS, NMSMAX_ENS 
  INTEGER(KIND=JPIM) :: NS3D, NS2D, NS1D, NVE3D, NVE2D
  INTEGER(KIND=JPIM) :: NENS 
  INTEGER(KIND=JPIM) :: NSIZEL, NSIZEG, NSCALES
  INTEGER(KIND=JPIM) :: NSIZES(7)
  TYPE(JB_CONTROL_VECTOR), POINTER  :: INITCV => NULL()
  TYPE(JB_CONTROL_VECTOR), POINTER  :: ENSCV => NULL()  
  REAL(KIND=JPRB), POINTER :: MODERR(:) => NULL()
  REAL(KIND=JPRB), POINTER :: TOVSCV(:) => NULL()
  REAL(KIND=JPRB), POINTER :: LAMCV (:) => NULL()
  REAL(KIND=JPRB), POINTER :: PARAMS(:) => NULL()
  REAL(KIND=JPRB), POINTER :: PECV(:) => NULL()
  LOGICAL :: LALLOC = .FALSE.
  TYPE(CONTROL_VECTOR_DATA_STRUCT), POINTER :: STRUCT => NULL()
  TYPE(CONTROL_VECTOR_DATA_STRUCT), POINTER :: STRUCT_ENS => NULL()
END TYPE CONTROL_VECTOR

! ------------------------------------------------------------------

INTERFACE ALLOCATE_CTLVEC
MODULE PROCEDURE ALLOCATE_CV, ALLOCATE_CV_CV
END INTERFACE

INTERFACE CHECK
MODULE PROCEDURE CHECK_CV, CHECK_CV_CV
END INTERFACE

INTERFACE OPERATOR (.EQV.)
MODULE PROCEDURE EQUIV_CV
END INTERFACE

INTERFACE OPERATOR (.NEQV.)
MODULE PROCEDURE NEQUIV_CV
END INTERFACE

! ------------------------------------------------------------------
CONTAINS
! ------------------------------------------------------------------

SUBROUTINE ALLOCATE_CV(YDCV,KSMAX,KMSMAX,KSMAX_ENS,KMSMAX_ENS,KMERR,KSERR,KPARAM,LDINIT,LDTOVS,&
                     & LDLAM,LDLENS,KS3D,KS2D,KS1D,KENS,KE3D,KE2D,KNSCALES)

USE YOMCT0, ONLY : LALLOPR
USE CONTROL_VECTORS_DATA_MIX, ONLY : CTLVEC_STRUCT, CTLVEC_STRUCT_ENS
TYPE(CONTROL_VECTOR), INTENT(OUT) :: YDCV
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: KSMAX,KMSMAX,KMERR,KSERR,KPARAM
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: KSMAX_ENS,KMSMAX_ENS 
LOGICAL, OPTIONAL, INTENT(IN) :: LDINIT,LDTOVS,LDLAM,LDLENS
INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: KS3D,KS2D,KS1D,KE3D,KE2D,KNSCALES,KENS

INTEGER(KIND=JPIM) :: IBGN_IC,IEND_IC,IBGN_ME,IEND_ME,IBGN_TV,IEND_TV,&
                    & IBGN_LA,IEND_LA,IBGN_PA,IEND_PA,IBGN_PP,IEND_PP,ILEN,&
                    & IBGN_EN,IEND_EN
TYPE(SPECTRAL_FIELD) :: YLSP

! Default values
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:ALLOCATE_CV',0,ZHOOK_HANDLE)

! Default values
IF (.NOT.ASSOCIATED(CTLVEC_STRUCT)) THEN
  CALL ABOR1('Trying to allocate a control_vector, but CTLVEC_STRUCT is not initialised')
ENDIF

YDCV%STRUCT => CTLVEC_STRUCT
YDCV%STRUCT_ENS => CTLVEC_STRUCT_ENS

YDCV%LINITCV   = YDCV%STRUCT%LINITCV
YDCV%LELAM     = YDCV%STRUCT%LELAM
YDCV%NSMAX     = YDCV%STRUCT%NSMAX
YDCV%NMSMAX    = YDCV%STRUCT%NMSMAX
YDCV%LENSCV = YDCV%STRUCT%LENSCV
IF (YDCV%LENSCV) THEN
   YDCV%NSMAX_ENS     = YDCV%STRUCT_ENS%NSMAX
   YDCV%NMSMAX_ENS    = YDCV%STRUCT_ENS%NMSMAX
   YDCV%NENS=YDCV%STRUCT_ENS%NENS
ENDIF
YDCV%NMODERR   = YDCV%STRUCT%NMODERR
YDCV%NSERR     = YDCV%STRUCT%NSERR
YDCV%LTOVSCV   = YDCV%STRUCT%LTOVSCV
YDCV%LAM1D     = YDCV%STRUCT%LELAM
YDCV%NS3D      = YDCV%STRUCT%NCTL3
YDCV%NS2D      = YDCV%STRUCT%NCTL2
YDCV%NS1D      = YDCV%STRUCT%NCTL1
YDCV%NVE3D     = YDCV%STRUCT%NVE3D
YDCV%NVE2D     = YDCV%STRUCT%NVE2D
YDCV%NS1D      = YDCV%STRUCT%NCTL1
YDCV%NPARA     = YDCV%STRUCT%NPARAM
YDCV%NPECV     = YDCV%STRUCT%NPECV
IF (YDCV%STRUCT%LWAVELETJB) THEN
  YDCV%NSCALES = YDCV%STRUCT%NSCALES
ENDIF
YDCV%NSIZES(:)=0

! Check for optional arguments
IF (PRESENT(LDINIT))   YDCV%LINITCV = LDINIT
IF (PRESENT(KSMAX))    YDCV%NSMAX   = KSMAX
IF (PRESENT(KMSMAX))   YDCV%NMSMAX  = KMSMAX
IF (PRESENT(KSMAX_ENS))    YDCV%NSMAX_ENS   = KSMAX_ENS
IF (PRESENT(KMSMAX_ENS))   YDCV%NMSMAX_ENS  = KMSMAX_ENS
IF (PRESENT(KMERR))    YDCV%NMODERR = KMERR
IF (PRESENT(KSERR))    YDCV%NSERR   = KSERR
IF (PRESENT(LDTOVS))   YDCV%LTOVSCV = LDTOVS
IF (PRESENT(LDLAM ))   YDCV%LAM1D   = LDLAM
IF (PRESENT(KS3D))     YDCV%NS3D    = KS3D
IF (PRESENT(KS2D))     YDCV%NS2D    = KS2D
IF (PRESENT(KS1D))     YDCV%NS1D    = KS1D
IF (PRESENT(KE3D))     YDCV%NVE3D   = KE3D
IF (PRESENT(KE2D))     YDCV%NVE2D   = KE2D
IF (PRESENT(KPARAM))   YDCV%NPARA   = KPARAM
IF (PRESENT(KNSCALES)) YDCV%NSCALES = KNSCALES
IF (PRESENT(LDLENS)) YDCV%LENSCV  = LDLENS
IF (PRESENT(KENS))  YDCV%NENS    = KENS

!cf To avoid stupid array bound violation
IF (YDCV%NS1D==0) YDCV%LAM1D=.FALSE.

IF (YDCV%LINITCV) THEN
  ALLOCATE(YDCV%INITCV)
  ! Setup Jb control vector, but don't allocate ydcv%initcv%data
  CALL ALLOCATE_JB_CTLVEC_NODATA(YDCV%INITCV,YDCV%NSMAX,YDCV%NMSMAX,&
                              &  YDCV%NS3D,YDCV%NS2D,YDCV%NS1D,YDCV%NSCALES,LLENS=.FALSE.)

  ! Reserve space in yd%data for the Jb control vector
  YDCV%NSIZEL=YDCV%INITCV%NSIZEL
  YDCV%NSIZEG=YDCV%INITCV%NSIZEG
  IBGN_IC = 1
  IEND_IC = YDCV%INITCV%NSIZEL
  YDCV%NSIZES(1)=YDCV%INITCV%NSIZEG
ELSE
  YDCV%NSIZEL=0
  YDCV%NSIZEG=0
ENDIF

IF (YDCV%LENSCV) THEN
   ALLOCATE(YDCV%ENSCV)
   ! Setup Ens-Jb control vector, but don't allocate ydcv%enscv%data
   CALL ALLOCATE_JB_CTLVEC_NODATA(YDCV%ENSCV,YDCV%NSMAX_ENS,YDCV%NMSMAX_ENS, &
        &  YDCV%NENS,YDCV%NENS,YDCV%NS1D,YDCV%NSCALES,LLENS=.TRUE.)
   ! Reserve space in yd%data for the Ens-Jb control vector
   ILEN = YDCV%ENSCV%NSIZEL
   IBGN_EN = YDCV%NSIZEL + 1
   IEND_EN = YDCV%NSIZEL + ILEN
   YDCV%NSIZEL=YDCV%NSIZEL + ILEN
   ILEN = YDCV%ENSCV%NSIZEG
   YDCV%NSIZEG=YDCV%NSIZEG + ILEN
   YDCV%NSIZES(2)=YDCV%ENSCV%NSIZEG
ENDIF

IF (YDCV%NMODERR>0) THEN

  CALL INQ_SPEC(YLSP,YDCV%STRUCT%NFLEVL,YDCV%STRUCT%NFLEVG,&
        & YDCV%STRUCT%NUMP,YDCV%STRUCT%MYMS,YDCV%NSERR,YDCV%NSERR,&
        & YDCV%STRUCT%NALLMS,YDCV%STRUCT%NPTRMS,YDCV%STRUCT%NUMLL,&
        & YDCV%STRUCT%NPTRLL,YDCV%STRUCT%NPSURF,YDCV%NVE3D,YDCV%NVE2D)

  ILEN = YDCV%NMODERR * YLSP%NSPSIZEL
  IBGN_ME = YDCV%NSIZEL + 1
  IEND_ME = YDCV%NSIZEL + ILEN
  YDCV%NSIZEL = YDCV%NSIZEL + ILEN
  ILEN = YDCV%NMODERR * YLSP%NSPSIZEG
  YDCV%NSIZEG = YDCV%NSIZEG + ILEN
  YDCV%NSIZES(3) = ILEN
  CALL DEALLOCATE_SPEC(YLSP)
ENDIF

IF (YDCV%LTOVSCV) THEN
  ILEN = YDCV%STRUCT%NLENTOVSCV*YDCV%STRUCT%NVATOVV
  IBGN_TV = YDCV%NSIZEL + 1
  IEND_TV = YDCV%NSIZEL + ILEN
  YDCV%NSIZEL = YDCV%NSIZEL + ILEN
  YDCV%NSIZEG = YDCV%NSIZEG + YDCV%STRUCT%NLENTOVSCVG*YDCV%STRUCT%NVATOVV
  YDCV%NSIZES(4)=YDCV%STRUCT%NLENTOVSCVG*YDCV%STRUCT%NVATOVV
ENDIF

IF (YDCV%LAM1D) THEN
  ILEN=YDCV%STRUCT%NFLEVL*YDCV%NS1D
  IBGN_LA = YDCV%NSIZEL + 1
  IEND_LA = YDCV%NSIZEL + ILEN
  YDCV%NSIZEL = YDCV%NSIZEL + ILEN
  YDCV%NSIZEG = YDCV%NSIZEG + YDCV%STRUCT%NFLEVG*YDCV%NS1D
  YDCV%NSIZES(5)=YDCV%STRUCT%NFLEVG*YDCV%NS1D
ENDIF

IF (YDCV%NPARA>0) THEN
  IBGN_PA = YDCV%NSIZEL + 1
  IEND_PA = YDCV%NSIZEL + YDCV%NPARA
  YDCV%NSIZEL = YDCV%NSIZEL + YDCV%NPARA
  YDCV%NSIZEG = YDCV%NSIZEG + YDCV%NPARA
  YDCV%NSIZES(6)=YDCV%NPARA
ENDIF

IF (YDCV%NPECV>0) THEN
  IBGN_PP = YDCV%NSIZEL + 1
  IEND_PP = YDCV%NSIZEL + YDCV%NPECV
  YDCV%NSIZEL = YDCV%NSIZEL + YDCV%NPECV
  YDCV%NSIZEG = YDCV%NSIZEG + YDCV%NPECV
  YDCV%NSIZES(7)=YDCV%NPECV
ENDIF

ALLOCATE(YDCV%DATA(1:YDCV%NSIZEL))
YDCV%LALLOC = .TRUE.

IF (YDCV%LINITCV  ) THEN
  YDCV%INITCV%DATA => YDCV%DATA(IBGN_IC:IEND_IC)
  YDCV%INITCV%LALLOC = .TRUE.
ENDIF

IF (YDCV%LENSCV  ) THEN
   YDCV%ENSCV%DATA => YDCV%DATA(IBGN_EN:IEND_EN)
   YDCV%ENSCV%LALLOC = .TRUE.
ENDIF

IF (YDCV%NMODERR>0) YDCV%MODERR => YDCV%DATA(IBGN_ME:IEND_ME)
IF (YDCV%LTOVSCV  ) YDCV%TOVSCV => YDCV%DATA(IBGN_TV:IEND_TV)
IF (YDCV%LAM1D    ) YDCV%LAMCV  => YDCV%DATA(IBGN_LA:IEND_LA)
IF (YDCV%NPARA>0  ) YDCV%PARAMS => YDCV%DATA(IBGN_PA:IEND_PA)
IF (YDCV%NPECV>0  ) YDCV%PECV   => YDCV%DATA(IBGN_PP:IEND_PP)

IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:ALLOCATE_CV',1,ZHOOK_HANDLE)
END SUBROUTINE ALLOCATE_CV

! ------------------------------------------------------------------

SUBROUTINE ALLOCATE_CV_CV(YDCV,YDIN)
TYPE(CONTROL_VECTOR), INTENT(OUT) :: YDCV
TYPE(CONTROL_VECTOR), INTENT(IN)  :: YDIN
LOGICAL :: LLENS

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:ALLOCATE_CV_CV',0,ZHOOK_HANDLE)
LLENS=YDIN%LENSCV

CALL ALLOCATE_CV(YDCV, KSMAX=YDIN%NSMAX, KSERR=YDIN%NSERR,LDLENS=LLENS)

IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:ALLOCATE_CV_CV',1,ZHOOK_HANDLE)
END SUBROUTINE ALLOCATE_CV_CV

! ------------------------------------------------------------------

SUBROUTINE DEALLOCATE_CTLVEC(YDCV)
TYPE(CONTROL_VECTOR), INTENT(INOUT) :: YDCV

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:DEALLOCATE_CTLVEC',0,ZHOOK_HANDLE)
IF (YDCV%LINITCV) THEN
  CALL DEALLOCATE_JB_CTLVEC_NODATA (YDCV%INITCV)
  DEALLOCATE(YDCV%INITCV)
  NULLIFY(YDCV%INITCV)
ENDIF

IF (YDCV%LENSCV) THEN
   CALL DEALLOCATE_JB_CTLVEC_NODATA (YDCV%ENSCV)
   DEALLOCATE(YDCV%ENSCV)
   NULLIFY(YDCV%ENSCV)
ENDIF

IF (ASSOCIATED(YDCV%MODERR)) NULLIFY(YDCV%MODERR)
IF (ASSOCIATED(YDCV%TOVSCV)) NULLIFY(YDCV%TOVSCV)
IF (ASSOCIATED(YDCV%LAMCV )) NULLIFY(YDCV%LAMCV )
IF (ASSOCIATED(YDCV%PARAMS)) NULLIFY(YDCV%PARAMS)
IF (ASSOCIATED(YDCV%PECV))   NULLIFY(YDCV%PECV)
IF (ASSOCIATED(YDCV%DATA)) DEALLOCATE(YDCV%DATA)
YDCV%LALLOC = .FALSE.

NULLIFY(YDCV%STRUCT)

IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:DEALLOCATE_CTLVEC',1,ZHOOK_HANDLE)
END SUBROUTINE DEALLOCATE_CTLVEC

! ------------------------------------------------------------------

SUBROUTINE CHECK_CV(YDCV)
TYPE(CONTROL_VECTOR), INTENT(IN) :: YDCV

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:CHECK_CV',0,ZHOOK_HANDLE)
IF (.NOT.(YDCV%LALLOC)) THEN
  CALL ABOR1('Control vector not allocated')
ENDIF
!yt the following is temporary, lalloc can be removed after
!yt this has been tested.
IF (ASSOCIATED(YDCV%DATA) .AND. .NOT.(YDCV%LALLOC)) THEN
  CALL ABOR1('Control vector associated but not lalloc')
ENDIF
IF (.NOT.ASSOCIATED(YDCV%DATA) .AND. YDCV%LALLOC) THEN
  CALL ABOR1('Control vector lalloc but not associated')
ENDIF

IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:CHECK_CV',1,ZHOOK_HANDLE)
END SUBROUTINE CHECK_CV

! ------------------------------------------------------------------

SUBROUTINE CHECK_CV_CV(YDCV1,YDCV2)
TYPE(CONTROL_VECTOR), INTENT(IN) :: YDCV1, YDCV2

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:CHECK_CV_CV',0,ZHOOK_HANDLE)
IF (.NOT.(YDCV1%LALLOC .AND. YDCV2%LALLOC)) THEN
  CALL ABOR1('Control vectors not allocated')
ENDIF
IF (YDCV1.NEQV.YDCV2) THEN
  CALL ABOR1('Control vectors are incompatible')
ENDIF

IF ((YDCV1%NSMAX/=YDCV2%NSMAX) .OR. (YDCV1%NSERR/=YDCV2%NSERR) .OR.&
 &((YDCV1%NMSMAX/=YDCV2%NMSMAX).AND.(YDCV1%LELAM))) THEN
  CALL ABOR1('Control vectors have different resolution')
ENDIF

IF (YDCV1%LENSCV .AND. YDCV2%LENSCV) THEN
  IF (YDCV1%NENS/=YDCV2%NENS) THEN
    CALL ABOR1('Control vectors have different ens. size')
  ENDIF
ENDIF
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:CHECK_CV_CV',1,ZHOOK_HANDLE)
END SUBROUTINE CHECK_CV_CV

! ------------------------------------------------------------------

LOGICAL FUNCTION EQUIV_CV(YDCV1,YDCV2)
TYPE(CONTROL_VECTOR), INTENT(IN) :: YDCV1
TYPE(CONTROL_VECTOR), INTENT(IN) :: YDCV2
LOGICAL :: LL

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:EQUIV_CV',0,ZHOOK_HANDLE)
LL = .TRUE.
LL = LL .AND. (YDCV1%LINITCV.EQV.YDCV2%LINITCV)
LL = LL .AND. (YDCV1%LENSCV.EQV.YDCV2%LENSCV)
LL = LL .AND. (YDCV1%LTOVSCV.EQV.YDCV2%LTOVSCV)
LL = LL .AND. (YDCV1%LAM1D  .EQV.YDCV2%LAM1D  )

LL = LL .AND. (YDCV1%NMODERR== YDCV2%NMODERR)
LL = LL .AND. (YDCV1%NS3D   == YDCV2%NS3D)
LL = LL .AND. (YDCV1%NS2D   == YDCV2%NS2D)
LL = LL .AND. (YDCV1%NS1D   == YDCV2%NS1D)
LL = LL .AND. (YDCV1%NVE3D  == YDCV2%NVE3D)
LL = LL .AND. (YDCV1%NVE2D  == YDCV2%NVE2D)
LL = LL .AND. (YDCV1%NPARA  == YDCV2%NPARA)
LL = LL .AND. (YDCV1%NPECV  == YDCV2%NPECV)
IF (YDCV1%LENSCV) THEN
  LL = LL .AND. (YDCV1%NENS  == YDCV2%NENS)
ENDIF

EQUIV_CV=LL
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:EQUIV_CV',1,ZHOOK_HANDLE)
END FUNCTION EQUIV_CV
  
! ------------------------------------------------------------------
  
LOGICAL FUNCTION NEQUIV_CV(YDCV1,YDCV2)
TYPE(CONTROL_VECTOR), INTENT(IN) :: YDCV1
TYPE(CONTROL_VECTOR), INTENT(IN) :: YDCV2
  
REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:NEQUIV_CV',0,ZHOOK_HANDLE)
NEQUIV_CV = .NOT. EQUIV_CV(YDCV1,YDCV2)
  
IF (LHOOK) CALL DR_HOOK('CONTROL_VECTORS_BASE_MIX:NEQUIV_CV',1,ZHOOK_HANDLE)
END FUNCTION NEQUIV_CV

! ------------------------------------------------------------------

END MODULE CONTROL_VECTORS_BASE_MIX
